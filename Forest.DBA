rem Nightmare Forest by Daniel Marschall
rem Revision: 06 Sep 2025

rem ---------------------

rem Severe Problems:
rem - DELL: MemBlock crash after resize dll gave size
rem - ELY3: extreme performance problems even with most modern graphics card!

rem SPRUNG-PHYSIK:
rem - wenn man die taste gedr¸ckt h‰lt, kann man gigantisch hoch springen
rem - wenn man auf einem baum landet, kann man von dort aus nicht springen, und glitched manchmal auf dem boden
rem   ... scheinbar ist die jumpheight = 0 dann!
rem - Sprung wirkt unrealistisch
rem - Anlaufsprung beim Rennen
rem - Im Sprung sollte man eigentlich nicht steuern d¸rfen...?

rem TODO: clone -> INSTANCE 
rem TODO: ambient light wird falsch verwendet. es ist viel zu blau, und alle objekte haben es deaktiviert, weil es die farben zerstˆrt
rem TODO: mehr konfigurierbar machen
rem TODO: map auﬂenlinie ist nicht gesperrt mit b‰umen oder eine grafik f¸r einen waldrand

rem TODO
rem - Delphi Launcher with Settings and Mapgen preview (optional)
rem - swimming
rem - walk slower in the water (also the enemies?)

rem Enemies:
rem - rascheln im busch
rem - die gegner kommen erst nach einer bestimmten zeit. spawnen mit entwas entfernung vom spieler
rem - scorpion schiebt stehenden spieler nicht weg
rem - scorpion soll nicht so nah rankommen, sodass er im spieler stehen w¸rde, wenn der spieler eingeklemmt ist

rem Radar:
rem - should be round, since it moves like in GTA
rem - should not be affected from resolution (i.e. on widescreen it must stay a circle)
rem - Don't show distant enemies
rem - blue point should always be in the center
rem - Radar wackelt?
rem - Radar lieber als Matrix anstelle als bild? Viele Probleme wie z.B. mit Skorpion transparenz
rem - Unscharfes Radar, Radar ganz dyn. zeichnen? Rader stay on top

rem Items:
rem - Karte
rem - Radar

rem MapGen32:
rem - Wegbreite konfigurierbar machen (INI)

rem Sonstiges:
rem - :startgame weglassen
rem - Streifen am Boden und am Himmel...
rem - Baum teiltransparenz
rem - Men¸: musik aus --> an: loop von position 0!
rem - wassermatrix bewegt sich nur in 1 richtung
rem - mausumkehrung einstellbar
rem - rennen verhindern, wenn man auﬂer puste

// --------------------------------
// Numerical Resources
// --------------------------------

#constant CAM_DEFAULT 0

#constant IMG_ForestFloor 1
#constant IMG_Water 3
#constant IMG_Tree 4
#constant IMG_MapBackground 5
#constant IMG_TitleScreen 95
#constant IMG_PauseScreen 96
#constant IMG_DeathScreen 97
#constant IMG_WinScreen 98

#constant OBJ_Tent 10
#constant OBJ_MapGhostObject 51
#constant OBJ_TreeTemplate 52
#constant OBJ_Monster_Base 1000
#constant OBJ_Tree_Base 1500

#constant MSH_TreeTemplate 52

#constant MAT_Ground 1
#constant MAT_Water 3

#constant SFX_ForestBG 1
#constant SFX_Walk_Earth 10
#constant SFX_Walk_Water 11
#constant SFX_Attack_Base 20
#constant SFX_TitleMusic 95
#constant SFX_PauseMusic 96
#constant SFX_DeathScreen 97
#constant SFX_WinScreen 98
#constant SFX_Monster_Base 1000

#constant DLL_MapGen 1
#constant DLL_DBIni 2
#constant DLL_Resize32 3
    
#constant MEM_Map 1
#constant MEM_ResizeSrc 2
#constant MEM_ResizeDest 3

// --------------------------------
// File names
// --------------------------------

#constant FN_DLL_Resize32         "dll_resize\Resize32.dll"
#constant FN_DLL_MapGen32         "mapgen\mapgen32.dll"
#constant FN_DLL_DBIni            "cfgread\dbini32.dll"

#constant FN_SFX_ForestBG         "sound\forestbg.wav"
#constant FN_SFX_Walk_Earth       "sound\walk.wav"
#constant FN_SFX_Walk_Water       "sound\walk_water.wav"
#constant FN_SFX_ScorpionAttack1  "sound\scorpionAttack\attack1.wav"
#constant FN_SFX_ScorpionAttack2  "sound\scorpionAttack\attack2.wav"
#constant FN_SFX_ScorpionAttack3  "sound\scorpionAttack\attack3.wav"
#constant FN_SFX_ScorpionAttack4  "sound\scorpionAttack\attack4.wav"
#constant FN_SFX_TitleMusic       "music\title.wav"
#constant FN_SFX_PauseMusic       "music\pause.wav"
#constant FN_SFX_Deathscreen      "sound\deathscreen.wav"
#constant FN_SFX_Winscreen        "sound\winscreen.wav"
#constant FN_SFX_ScorpWalk        "sound\scorp_walk.wav"

#constant FN_OBJ_ScorpIdle        "obj\scorpion\ScorpIdle.x"
#constant FN_OBJ_ScorpWalk        "obj\scorpion\ScorpWalk.x"
#constant FN_OBJ_Tent             "obj\tent\Tent.x"

#constant FN_GFX_FloorTexture     "bitmap\forest_floor_texture.jpg"
#constant FN_GFX_Water            "bitmap\water.bmp"
#constant FN_GFX_Tree             "bitmap\tree.bmp"
#constant FN_GFX_MapBackground    "bitmap\radar.bmp"
#constant FN_GFX_TitleScreen      "bitmap\titlescreen.jpg"
#constant FN_GFX_PauseScreen      "bitmap\pausescreen.jpg"
#constant FN_GFX_DeathScreen      "bitmap\deathscreen.jpg"
#constant FN_GFX_WinScreen        "bitmap\winscreen.jpg"

#constant FN_INI_SETTINGS         "forest.ini"
#constant FN_INI_SEED             "seed.ini"

// --------------------------------
// Read configuration
// --------------------------------

load dll FN_DLL_DBIni, DLL_DBIni
call dll DLL_DBIni, "LoadINI", FN_INI_SETTINGS
maxFramerate                = call dll(DLL_DBIni, "ReadInt",   "Game", "maxFramerate",                30)
screenResW                  = call dll(DLL_DBIni, "ReadInt",   "Game", "screenResW",                  800)
screenResH                  = call dll(DLL_DBIni, "ReadInt",   "Game", "screenResH",                  600)
screenResB                  = call dll(DLL_DBIni, "ReadInt",   "Game", "screenResB",                  16)
clockSpeedFactor            = call dll(DLL_DBIni, "ReadInt",   "Game", "clockSpeedFactor",            1)
clockBlinksPerSecond        = call dll(DLL_DBIni, "ReadInt",   "Game", "clockBlinksPerSecond",        0)
clockShowSeconds            = call dll(DLL_DBIni, "ReadInt",   "Game", "clockShowSeconds",            0)
beginClockSeconds           = call dll(DLL_DBIni, "ReadInt",   "Game", "beginClockSeconds",           22*60*60)
surviveTill                 = call dll(DLL_DBIni, "ReadInt",   "Game", "surviveTill",                 7*60*60)
enemyRotateSmoothness       = call dll(DLL_DBIni, "ReadInt",   "Game", "enemyRotateSmoothness",       0)
maxRunEnergy                = call dll(DLL_DBIni, "ReadInt",   "Game", "maxRunEnergy",                0)
waterLevel                  = call dll(DLL_DBIni, "ReadInt",   "Game", "waterLevel",                  0)
sound3dVolumeCor            = call dll(DLL_DBIni, "ReadInt",   "Game", "sound3dVolumeCor",            0)
invertMouse                 = call dll(DLL_DBIni, "ReadInt",   "Game", "invertMouse",                 0)
test                        = call dll(DLL_DBIni, "ReadInt",   "Game", "test",                        0)
camerarange                 = call dll(DLL_DBIni, "ReadInt",   "Game", "camerarange",                 0)
fogdistance                 = call dll(DLL_DBIni, "ReadInt",   "Game", "fogdistance",                 0)
waterMovementMaxDistance    = call dll(DLL_DBIni, "ReadInt",   "Game", "waterMovementMaxDistance",    0)
gravity#                    = call dll(DLL_DBIni, "ReadFloat", "Game", "gravity",                     0.0)
JumpStartVelocity#          = call dll(DLL_DBIni, "ReadFloat", "Game", "JumpStartVelocity",           0.0)
MinFallVelocity#            = call dll(DLL_DBIni, "ReadFloat", "Game", "MinFallVelocity",             0.0)
scorpCollissionX#           = call dll(DLL_DBIni, "ReadFloat", "Game", "scorpCollissionX",            0.0)
scorpCollissionY#           = call dll(DLL_DBIni, "ReadFloat", "Game", "scorpCollissionY",            0.0)
scorpCollissionZ#           = call dll(DLL_DBIni, "ReadFloat", "Game", "scorpCollissionZ",            0.0)
playerEyeHeight#            = call dll(DLL_DBIni, "ReadFloat", "Game", "playerEyeHeight",             0.0)
cMaxTrees                   = call dll(DLL_DBIni, "ReadInt",   "Game", "cMaxTrees",                   0)
cMapSizeX                   = call dll(DLL_DBIni, "ReadInt",   "Game", "cMapSizeX",                   0)
cMapSizeZ                   = call dll(DLL_DBIni, "ReadInt",   "Game", "cMapSizeZ",                   0)
cTreeRadius                 = call dll(DLL_DBIni, "ReadInt",   "Game", "cTreeRadius",                 0)
cMaxEnemies                 = call dll(DLL_DBIni, "ReadInt",   "Game", "cMaxEnemies",                 0)
HitInterval                 = call dll(DLL_DBIni, "ReadInt",   "Game", "HitInterval",                 0)
maxHitsTillDeath            = call dll(DLL_DBIni, "ReadInt",   "Game", "maxHitsTillDeath",            20);
initialEnemySafezone#       = call dll(DLL_DBIni, "ReadFloat", "Game", "InitialEnemySafezone",        1000.0)
cEnemySpawnMapBorderPadding = call dll(DLL_DBIni, "ReadInt",   "Game", "EnemySpawnMapBorderPadding",  1000)
call dll DLL_DBIni, "UnloadINI"
delete dll DLL_DBIni

rem TODO: Even on a NVIDIA GeForce RTX 5080 and resolution 1024x768,
rem       I cannot get 30 FPS! What is going on?! And with higher resolutions such as 2560x1440,
rem       it is unplayable!
set display mode screenResW, screenResH, screenResB

hide mouse

Sync On
Sync Rate maxFramerate

LoadImageFullscreen(FN_GFX_TitleScreen, IMG_TitleScreen)

PASTE IMAGE IMG_TitleScreen, 0, 0

rem Sync twice at application start for friendliness with dbpro's double buffering
rem (Required for newer versions of DB Pro)
sync : sync

_startgame:

ink rgb(255, 230, 0), 0
PASTE IMAGE IMG_TitleScreen, 0, 0
set text font "Arial" : set text size 30 : set text transparent
text 28, 550, "Starting game..."

load sound FN_SFX_TitleMusic, SFX_TitleMusic
loop sound SFX_TitleMusic

sync

randomize timer()

rem To test title screen
rem sleep 5*1000

rem Working variables ONLY
JumpKeyStatePrev = 0
JumpPosition# = 0.0
onGround = 1
velocityY# = 0.0
runEnergy# = maxRunEnergy
clockSeconds = beginClockSeconds
collcounter = 0
hits = 0
LastAttackSound = 0
fogColorR = 0
fogColorG = 0
fogColorB = 0
radarpointcolor = 150
underAttack = 0
attackHudColorStrength = 0

draw to front

gosub _setup_camera
gosub _create_floor
gosub _setup_player_position
gosub _create_trees
gosub _draw_trees
gosub _create_water
gosub _create_radar

rem Bildschirm neu aufbauen
cls
sync

rem TODO: Lichtversuch
make light 1

gosub _create_enemies
gosub _setupClock

load sound FN_SFX_ForestBG,   SFX_ForestBG
load sound FN_SFX_Walk_Earth, SFX_Walk_Earth
load sound FN_SFX_Walk_Water, SFX_Walk_Water
load sound FN_SFX_PauseMusic, SFX_PauseMusic
load sound FN_SFX_DeathScreen, SFX_DeathScreen
load sound FN_SFX_WinScreen, SFX_WinScreen

#constant NumberOfAttackSounds 4
load sound FN_SFX_ScorpionAttack1, SFX_Attack_Base+0
load sound FN_SFX_ScorpionAttack2, SFX_Attack_Base+1
load sound FN_SFX_ScorpionAttack3, SFX_Attack_Base+2
load sound FN_SFX_ScorpionAttack4, SFX_Attack_Base+3

LoadImageFullscreen(FN_GFX_PauseScreen, IMG_PauseScreen)
LoadImageFullscreen(FN_GFX_DeathScreen, IMG_DeathScreen)
LoadImageFullscreen(FN_GFX_WinScreen,   IMG_WinScreen)

Disable EscapeKey

stop sound SFX_TitleMusic
loop sound SFX_ForestBG

rem Hauptschleife
do
    gosub _handle_weather
    gosub _handle_player
    gosub _update_trees
    gosub _handle_radar
    gosub _handle_enemies
    gosub _handleClock
   
    underAttack = 0
    for t = 0 to cMaxEnemies-1
        dx# = abs(object position x(OBJ_Monster_Base+t) - camera position x())
        dy# = abs(object position y(OBJ_Monster_Base+t) - camera position y())
        dz# = abs(object position z(OBJ_Monster_Base+t) - camera position z())
        if dx# < scorpCollissionX# and dy# < scorpCollissionY# and dz# < scorpCollissionZ#
            collcounter = collcounter + 1
            underAttack = underAttack + 1
            rem print "DEBUG: Attacking enemy: X", dx#, ", Y", dy#, ", Z", dz#
        endif
    NEXT
    rem print "DEBUG: Collision counter: ", collcounter
    
    if underAttack = 0
        collcounter = collcounter - 1
        if collcounter < 0 then collcounter = 0
    endif
        
    if collcounter >= HitInterval
        collcounter = 0
        inc hits, 1
        gosub _play_attack_sound
    endif
    rem print "Hits: ", hits
    
    health# = 100.0 - hits*100.0/maxHitsTillDeath
    print "Health: ", Floor(health#), "%"    

    if hits >= maxHitsTillDeath then gosub _deathscreen
    if clockSeconds >= surviveTill and clockSeconds < surviveTill+1*60*60 then gosub _winscreen
    
    if EscapeKey() = 1
        repeat
            sync
        until not (EscapeKey() = 1)
        gosub _pausemenu
    endif
    sceneInitialized=1
    sync
loop

_pausemenu:
    gosub _stop_game_sounds
    loop sound SFX_PauseMusic
    rem show mouse 
    
    repeat
        cls
        
        paste image IMG_PauseScreen, 0, 0
                
        rem Text
        ink rgb(255,255,255),1
        rem text 100,100,"text"
                
        text 28, 550, "Pause. ESC=Continue. DownKey=End."
        sync
        
        if DownKey() = 1
            goto _exit
        ENDIF
    UNTIL EscapeKey() = 1
    repeat
        sync
    until not (EscapeKey() = 1)
    rem hide mouse
    stop sound SFX_PauseMusic
    loop sound SFX_ForestBG
    
    rem TODO: das bringt nix. wenn man die maus bewegt, wird nach der pause die kamera gescrollt
    set cursor 0, 0
return

_deathscreen:
    gosub _stop_game_sounds
    play sound SFX_DeathScreen
    rem show mouse 
    
    cls
    
    paste image IMG_DeathScreen, 0, 0
            
    rem Text
    ink rgb(255,255,255),1
    rem text 100,100,"text"
            
    sync
    
    Sleep 7*1000
    
    goto _exit    
return

_winscreen:
    gosub _stop_game_sounds
    play sound SFX_WinScreen
    rem show mouse 
    
    cls
    
    paste image IMG_WinScreen, 0, 0
            
    rem Text
    ink rgb(255,255,255),1
    rem text 100,100,"text"
            
    sync
    
    Sleep 7*1000
    
    goto _exit    
return

_setup_camera:
    Set camera range 1, camerarange
    AUTOMATIC CAMERA COLLISION CAM_DEFAULT, collissionboxsize#, 0 : rem scorpione stoﬂen den spieler nicht weg, wenn keine taste gedr¸ckt wird? syntax mit 4 parametern funktioniert im neuen dbpro free nicht!
    Autocam off
return

_setup_player_position:
    X# = cMapSizeX / 2
    Y# = floorHeight#(X#, Z#) + playerEyeHeight
    Z# = cMapSizeZ / 2
    position camera X#, Y#, Z#
    
    rem TODO zelt ist winzig klein!
    rem TODO zelt ist schwarz schattiert
    rem TODO zelt beleuchten
    rem Load object FN_OBJ_Tent, OBJ_Tent
    rem show object OBJ_Tent
    rem scale object OBJ_Tent, 10000, 5000, 5000
    rem position object OBJ_Tent, X#-20, Y#, Z#-10
return

_handle_weather:

    rem TODO: Konstanten in INI einstellbar machen
    sunriseStart = 5 * 3600    : rem D‰mmerungsbeginn, z.B. 05:00
    sunriseEnd   = 7 * 3600    : rem Sonnenaufgang voll, z.B. 07:00
    sunsetStart  = 17 * 3600   : rem Sonnenuntergang beginnt, z.B. 17:00
    sunsetEnd    = 19 * 3600   : rem D‰mmerungsende, z.B. 19:00
    nightLevel#  = 0.0         : rem Minimale Helligkeit nachts, z.B. Mondschein
    dayPeak#     = 255.0       : rem Helligkeit am Mittag
    if clockSeconds < sunriseStart or clockSeconds > sunsetEnd
        lightValue = INT(nightLevel# + 0.5)
    else
        rem gesamte Tagesspanne von D‰mmerungsbeginn bis -ende
        daySpanStart = sunriseStart
        daySpanEnd   = sunsetEnd

        duration# = (daySpanEnd - daySpanStart) * 1.0    : rem float-sicher
        u# = (clockSeconds - daySpanStart) / duration#   : rem 0..1
        if u# < 0.0 then u# = 0.0
        if u# > 1.0 then u# = 1.0

        rem Sinuskurve: 0 am D‰mmerungsbeginn, 1 in der Mitte (Mittag), 0 am D‰mmerungsende
        daylightFactor# = sin(u# * 180)
    
        rem Auf Zielbereich (nightLevel .. dayPeak) skalieren
        lightValue# = nightLevel# + daylightFactor# * (dayPeak# - nightLevel#)

        rem numerische Sicherheit & auf 0..255 clampen
        if lightValue# < 0.0 then lightValue# = 0.0
        if lightValue# > 255.0 then lightValue# = 255.0

        lightValue = INT(lightValue# + 0.5)
    endif
    rem print "DEBUG: clockSeconds:", clockSeconds, " => lightValue:", lightValue

    fogColorR = lightValue
    fogColorG = lightValue
    fogColorB = lightValue
    
    if underAttack > 0
        attackHudColorStrength = attackHudColorStrength + 10
        if attackHudColorStrength > 255 then attackHudColorStrength = 255
    else
        attackHudColorStrength = attackHudColorStrength - 10
        if attackHudColorStrength < 0 then attackHudColorStrength = 0
    endif
    
    fogColorR = fogColorR + attackHudColorStrength
    if fogColorR > 255 then fogColorR = 255
    
    fogColorG = fogColorG - attackHudColorStrength
    if fogColorG < 0 then fogColorG = 0
   
    fogColorB = fogColorB - attackHudColorStrength
    if fogColorB < 0 then fogColorB = 0
   
    backdrop on
    color backdrop rgb(fogColorR, fogColorG, fogColorB)

    rem color ambient light rgb(64,64,128)
    rem set ambient light 1
    rem set ambient light 50
    if fog available() = 1
        fog on
        fog distance fogdistance
        fog color rgb(fogColorR, fogColorG, fogColorB)
    endif
   
    if test = 1
        SET MATRIX WIREFRAME ON MAT_Ground
        SET MATRIX WIREFRAME ON MAT_Water
    endif
   
   
    rem Water movement
    rem TODO: wasser soll sich langsamer bewegen, aber das ist schwierig. wenn man die bewegung nur zu bestimmten ticks
    rem       durchf¸hrt, dann ruckelt es.
    waterdir = (waterdir + 1) mod 360;
    watermov = 0 + cos(waterdir)*waterMovementMaxDistance
    position matrix MAT_Water, watermov, waterLevel, watermov
return

_handle_enemies:
    pX# = Camera Position X()
    pZ# = Camera Position Z()
    
    rem TODO: gegner sollen sich nicht ¸berschneiden
    
    for t = 0 to cMaxEnemies-1
        eX# = Object Position X(OBJ_Monster_Base+t)
        eY# = Object Position Y(OBJ_Monster_Base+t)
        eZ# = Object Position Z(OBJ_Monster_Base+t)
       
        eRX# = Object Angle X(OBJ_Monster_Base+t)
        eRY# = Object Angle Y(OBJ_Monster_Base+t)
        eRZ# = Object Angle Z(OBJ_Monster_Base+t)
       
        deltaX# = pX#-eX#
        deltaZ# = pZ#-eZ#

        rem TODO: cor file
        yPosOffset# = 20
        
        dist# = sqrt( deltaX#*deltaX# + deltaZ#*deltaZ# )
        
        if clockSeconds > 1
            if not sound playing(SFX_Monster_Base+t)
                set sound volume SFX_Monster_Base+t, 0
                
                rem TODO: beliebiges startoffset?
                loop sound SFX_Monster_Base+t
            endif
        endif
        
        rem The mixing of 3dsound is bullshit (too loud from far distance, and not very loud on close distance),
        rem so we mix the volume ourself
        if sound3dVolumeCor>0 and dist#<sound3dVolumeCor then set sound volume SFX_Monster_Base+t, (1-(dist#/sound3dVolumeCor))*100
        
        rem TODO: 100 dynamisch machen
        rem at least a distance of 10 so that atanfull() does not bug, when deltas becomes 0
        rem Verhindern, dass der Skorpion in einem "drin" steht. Er soll mit den Scheren angreifen
        scorpMinDistance = 100
        
        if dist# > scorpMinDistance
            if dist# < enemy(t).AwarenessRadius
                enemy(t).Angle = atanfull(deltaX#, deltaZ#)
                enemy(t).Angle = WrapValue(enemy(t).Angle+180)
                enemy(t).CurSpeed = enemy(t).MaxSpeed
            else
                if enemy(t).WalkTimeout <= 0
                    enemy(t).WalkTimeout = RndBetween(enemy(t).WalkTimeoutMin, enemy(t).WalkTimeoutMax)
                    enemy(t).Angle = RndBetween(0,359)
                    enemy(t).CurSpeed = RndBetween(0, enemy(t).MaxSpeed)
                ENDIF
                enemy(t).WalkTimeout = enemy(t).WalkTimeout - 1
            endif
            
            if enemy(t).CurSpeed = 0
                gosub scorpChangeToIdle
            else
                gosub scorpChangeToWalk
                rem TODO: also make animation slower/faster
            endif

            a# = WrapValue(enemy(t).Angle + 180)
            XTest# = Newxvalue(eX#, a#, enemy(t).CurSpeed)
            ZTest# = Newzvalue(eZ#, a#, enemy(t).CurSpeed)
            if XTest# > 0 and XTest# < cMapSizeX then eX# = XTest#
            if ZTest# > 0 and ZTest# < cMapSizeZ then eZ# = ZTest#
            if XTest# <= 0 or XTest# >= cMapSizeX or ZTest# <= 0 or ZTest# >= cMapSizeZ
                rem Kehrtwende, um den Kartenrand zu verlassen
                enemy(t).Angle = WrapValue(enemy(t).Angle+180)
                enemy(t).WalkTimeout = RndBetween(enemy(t).WalkTimeoutMin, enemy(t).WalkTimeoutMax)
                enemy(t).CurSpeed = RndBetween(0, enemy(t).MaxSpeed)
            endif
    
            eY# = floorHeight#(eX#, eZ#) + yPosOffset#
            Position Object OBJ_Monster_Base+t, eX#, eY#, eZ#
            Position Sound SFX_Monster_Base+t, eX#, eY#, eZ#
            
            eRY# = smoothRotate#(eRY#, enemy(t).Angle, enemyRotateSmoothness)
            rotate object OBJ_Monster_Base+t, eRX#, eRY#, eRZ#
        endif
    next
return

#constant GROUNDTYPE_AIR 0
#constant GROUNDTYPE_EARTH 1
#constant GROUNDTYPE_WATER 2
rem #constant GROUNDTYPE_DEEPWATER 3
function groundType(onGround, waterLevel)
    if onGround = 0
        ret = GROUNDTYPE_AIR
    else
        X# = camera position x()
        Z# = camera position z()
        if floorHeight#(X#,Z#) > waterLevel
            ret = GROUNDTYPE_EARTH
        else
            ret = GROUNDTYPE_WATER
        endif
    endif
endfunction ret

_handle_player:
    set cursor 0, 0
    oldcAY# = cAY#
    oldcAX# = cAX#
       
    X# = camera position x()
    Y# = camera position y()
    Z# = camera position z()

    if invertMouse = 1
        cAX# = WrapValue(cAX# - MousemoveY() * 0.2)
    else
        cAX# = WrapValue(cAX# + MousemoveY() * 0.2)
    endif
    cAY# = WrapValue(cAY# + MousemoveX() * 0.2)
    cAZ# = Camera angle Z()   

    rem Sprungroutine
    rem TODO: + Anlaufsprung
   
    JumpKeyStateNow=jumpPressed()
    if (JumpKeyStatePrev=0) and (JumpKeyStateNow=1)
        gosub PressJumpKey
    ENDIF
    if (JumpKeyStatePrev=1) and (JumpKeyStateNow=0)
        gosub ReleaseJumpKey
    ENDIF
    JumpKeyStatePrev = JumpKeyStateNow
    gosub JumpUpdate
       
    rem Laufen
    speedboost# = 1
    
    gt = groundType(onGround, waterLevel)
    
    if upPressed()+downPressed()+leftPressed()+rightPressed() = 0
        runEnergy# = runEnergy# + 2
        stop sound SFX_Walk_Earth
        stop sound SFX_Walk_Water
    else
        if gt = GROUNDTYPE_EARTH
            stop sound SFX_Walk_Water
            if not sound playing(SFX_Walk_Earth)
                   loop sound SFX_Walk_Earth
            endif
        endif
        if gt = GROUNDTYPE_WATER
            stop sound SFX_Walk_Earth
            if not sound playing(SFX_Walk_Water)
                   loop sound SFX_Walk_Water
            endif
        endif
        if gt = GROUNDTYPE_AIR
            stop sound SFX_Walk_Earth
            stop sound SFX_Walk_Water
        endif
        energyChanged = 0
        if ShiftKey()+ControlKey() = 1 : rem shift+control at the same time = walk normal
            rem TODO: es ruckelt trotzdem noch
            if ControlKey()=1 and runEnergy#>0 : rem Energy >1 , damit es nicht ruckelt (run-walk-run-walk-run-walk) . 3 = walk regain
                speedboost# = 2
                runEnergy# = runEnergy# - 1
                energyChanged = 1
            endif
            if ShiftKey()=1
                speedboost# = 0.5
                runEnergy# = runEnergy# + 0.5
                energyChanged = 1
            endif
        endif
        if not energyChanged then runEnergy# = runEnergy# + 1
        if upPressed()
            XTest# = Newxvalue(X#, cAY#, 7*speedboost#)
            ZTest# = Newzvalue(Z#, cAY#, 7*speedboost#)
            gosub _WorldBoundCheck
        endif
        if downPressed()
            XTest# = Newxvalue(X#, Wrapvalue(cAY# - 180), 5*(speedboost#/2))
            ZTest# = Newzvalue(Z#, Wrapvalue(cAY# - 180), 5*(speedboost#/2))
            gosub _WorldBoundCheck
        endif
        if leftPressed()
            XTest# = Newxvalue(X#, Wrapvalue(cAY# - 90), 5*(speedboost#/1.3))
            ZTest# = Newzvalue(Z#, Wrapvalue(cAY# - 90), 5*(speedboost#/1.3))
            gosub _WorldBoundCheck
        endif
        if rightPressed()
            XTest# = Newxvalue(X#, Wrapvalue(cAY# + 90), 5*(speedboost#/1.3))
            ZTest# = Newzvalue(Z#, Wrapvalue(cAY# + 90), 5*(speedboost#/1.3))
            gosub _WorldBoundCheck
        endif
    endif
    if runEnergy# > maxRunEnergy then runEnergy# = maxRunEnergy
    
    runEnergyPercent# = runEnergy#*100.0/maxRunEnergy
    print "Run Energy: ", Floor(runEnergyPercent#), "%"

    Rem Rotate camera
    cTestX# = WrapValue(cAX# - 180)
    if cTestX# > 225 then cAX# = 45
    if cTestX# < 135 then cAX# = 315
    YRotate camera CurveAngle(cAY#, oldcAY#, 24)
    XRotate camera CurveAngle(cAX#, oldcAX#, 24)

    Rem Position Camera
    if onGround=1
        Y#=floorHeight#(X#, Z#)
    else
        Y#=JumpPosition#
    ENDIF
    inc Y#, playerEyeHeight#
    Position Camera X#, Y#, Z#

    Rem Position Listener
    Position Listener X#, Y#, Z#
    Rotate Listener 0, cAY#, 0   : rem todo warum 0 statt cAZ# etc ?

    rem if onGround = 0
    rem     jumpheight#=Y#-FloorHeight#(X#,Z#)
    rem else
    rem     jumpheight#=0
    rem endif

return    

_WorldBoundCheck:
    if XTest# > 0 and XTest# < cMapSizeX then X# = XTest#
    if ZTest# > 0 and ZTest# < cMapSizeZ then Z# = ZTest#
return
    
_update_trees:
    if (ceil(X#) mod 10 = 0) or (ceil(Z#) mod 10 = 0) or (sceneInitialized=0)
        for t = 0 to cMaxTrees-1
            rx = tree(t).x
            rz = tree(t).z
            incircle = IsInCircle(rx, rz, X#, Z#, camerarange)
            rem incircle = IsInCircle(rx, rz, X#, Z#, fogdistance)
            if incircle <> tree(t).drawn
                if incircle = 1
                    if object exist(OBJ_Tree_Base+t)
                        show object OBJ_Tree_Base+t
                    else
                        make object OBJ_Tree_Base+t, MSH_TreeTemplate, IMG_Tree
                        position object OBJ_Tree_Base+t, rx, floorHeight#(rx, rz)+190, rz
                        set object OBJ_Tree_Base+t, 1, 1, 0
                        rotate object OBJ_Tree_Base+t, 0, RndBetween(0,359), 0
                    endif
                else
                    delete object OBJ_Tree_Base+t
                    rem hide object OBJ_Tree_Base+t
                endif 
            ENDIF      
            tree(t).drawn = incircle
        next t
    endif
return

_handle_radar:
    rem TODO: the player dot should always stay at the same position
    rem TODO: don't show far away enemies
    
    rem Leuchtpunkt
    if radarpointrev = 0
        inc radarpointcolor, 3
    else
        dec radarpointcolor, 3
    endif
    if radarpointcolor > 255
        radarpointrev = 1
        radarpointcolor = 254
    endif
    if radarpointcolor < 150
        radarpointrev = 0
        radarpointcolor = 149
    endif
    rem B‰ume
    for t = 0 to cMaxTrees-1
        if tree(t).drawn
            x = tree(t).x
            y = tree(t).z

            x0 = camera position x()
            y0 = camera position z()
            ang = camera angle y()
            tx = x0 + (x-x0)*cos(ang) - (y-y0)*sin(ang)
            ty = y0 + (x-x0)*sin(ang) + (y-y0)*cos(ang)
            x = tx
            y = ty
            
            x = (x / 62.5) + 7.5
            y = screen height() - 7.5 - (y / 62.5)
            
            rem ink rgb(0, radarpointcolor, 0), 0
            ink rgb(0, 50, 0), 0
            circle x, y, 1
            circle x, y, 0
        endif
    next i
    rem Player
    x = (X# / 62.5) + 7.5
    y = screen height() - 7.5 - (Z# / 62.5)
    ink rgb(0, 0, radarpointcolor), 0
    circle x, y, 1
    circle x, y, 0
    rem Enemies
    for t = 0 to cMaxEnemies-1
        x = object position x(OBJ_Monster_Base+t)
        y = object position z(OBJ_Monster_Base+t)
        
        x0 = camera position x()
        y0 = camera position z()
        ang = camera angle y()
        tx = x0 + (x-x0)*cos(ang) - (y-y0)*sin(ang)
        ty = y0 + (x-x0)*sin(ang) + (y-y0)*cos(ang)
        x = tx
        y = ty
        
        x = (x / 62.5) + 7.5
        y = screen height() - 7.5 - (y / 62.5)
        
        ink rgb(radarpointcolor, 0, 0), 0
        circle x, y, 1
        circle x, y, 0
    next
return

_draw_trees:
    rem TODO: da ist ein baum an offset 0,0,0
    load image FN_GFX_Tree, IMG_Tree
    
    make object plain OBJ_TreeTemplate, 2*cTreeRadius, 400
    make mesh from object MSH_TreeTemplate, OBJ_TreeTemplate
    add limb OBJ_TreeTemplate, 1, MSH_TreeTemplate
    rotate limb OBJ_TreeTemplate, 1, 0, 90, 0
    make mesh from object MSH_TreeTemplate, OBJ_TreeTemplate
    delete object OBJ_TreeTemplate
return

_create_trees:
    dim tree(cMaxTrees-1) as treeType
    
    remstart
    for t = 0 to cMaxTrees-1
        tree(t).x = RndBetween(0, cMapSizeX) 
        tree(t).z = RndBetween(0, cMapSizeZ) 
        tree(t).drawn = 0
    NEXT
    remend
       
    rem TODO: wegbreite definieren
    load dll FN_DLL_MapGen32, DLL_MapGen
    call dll DLL_MapGen, "LoadParametersFromINI", FN_INI_SETTINGS

    load dll FN_DLL_DBIni, DLL_DBIni
    call dll DLL_DBIni, "LoadINI", FN_INI_SEED
    onetimeseed = call dll(DLL_DBIni, "ReadInt", "Seed", "onetime", 0)
    staticseed  = call dll(DLL_DBIni, "ReadInt", "Seed", "value", 0)
    seedactive  = call dll(DLL_DBIni, "ReadInt", "Seed", "active", 0)
    IF (onetimeseed = 1) AND (seedactive = 1)
        call dll DLL_DBIni, "WriteInt", "Seed", "active", 0
    ENDIF
    IF seedactive
        call dll DLL_MapGen, "UseSeed", staticseed
    ELSE
        call dll DLL_MapGen, "RandomSeed"
    ENDIF
    call dll DLL_DBIni, "UnloadINI"
    delete dll DLL_DBIni
    
    make memblock MEM_Map, cMaxTrees*8
    call dll DLL_MapGen, "GenerateMap", cMaxTrees, cTreeRadius, cMapSizeX, cMapSizeZ, get memblock ptr(MEM_Map), 0
    for t = 0 to cMaxTrees-1
        tree(t).x = memblock dword(MEM_Map, t*8)
        tree(t).z = memblock dword(MEM_Map, t*8+4)
        tree(t).drawn = 0
    NEXT
    delete memblock MEM_Map
    delete dll DLL_MapGen
return

_create_enemies:
    dim enemy(cMaxEnemies-1) as enemyType
    for t = 0 to cMaxEnemies-1
        if t=0
            rem NOTE: 3DSound requires Mono audio!
            Load 3Dsound FN_SFX_ScorpWalk, SFX_Monster_Base+t
        else
            Clone Sound SFX_Monster_Base+t, SFX_Monster_Base
        endif

        pX# = Camera Position X()
        pY# = Camera Position Y()
        pZ# = Camera Position Z()

        repeat
            eX# = RndBetween(cEnemySpawnMapBorderPadding, cMapSizeX-cEnemySpawnMapBorderPadding)
            eZ# = RndBetween(cEnemySpawnMapBorderPadding, cMapSizeZ-cEnemySpawnMapBorderPadding)
            deltaX# = pX#-eX#
            deltaZ# = pZ#-eZ#
            dist# = sqrt( deltaX#*deltaX# + deltaZ#*deltaZ# )
            rem Prevent that the enemies spawn right at the player (5000/5000)
        until dist# >= initialEnemySafezone#
        enemy(t).AwarenessRadius = RndBetween(600, 1300)
        enemy(t).MaxSpeed = RndBetween(1, 4)
        enemy(t).WalkTimeoutMin = 200
        enemy(t).WalkTimeoutMax = 300
        
        if t = 0
            animScorpIdleStart = 0
            Load object FN_OBJ_ScorpIdle, OBJ_Monster_Base+t
            animScorpIdleEnd = total object frames(OBJ_Monster_Base+t)
            
            animScorpWalkStart = animScorpIdleEnd+1
            Append object FN_OBJ_ScorpWalk, OBJ_Monster_Base+t, animScorpWalkStart
            animScorpWalkEnd = total object frames(OBJ_Monster_Base+t)
        else
            Clone Object OBJ_Monster_Base+t, OBJ_Monster_Base        
        endif
        
        eY# = floorHeight#(eX#, eZ#) : rem TODO  + yPosOffset#
        position object OBJ_Monster_Base+t, eX#, eY#, eZ#
        Position Sound SFX_Monster_Base+t, eX#, eY#, eZ#
        
        fix object pivot OBJ_Monster_Base+t
        gosub scorpChangeToWalk
        set object collision on OBJ_Monster_Base+t
    NEXT
return

scorpChangeToIdle:
    rem TODO: smoothness (interpolation)
    if enemy(t).CurrentAnim <> 1
        loop object OBJ_Monster_Base+t, animScorpIdleStart, animScorpIdleEnd
        enemy(t).CurrentAnim = 1
    endif
return

scorpChangeToWalk:
    rem TODO: smoothness (interpolation)
    if enemy(t).CurrentAnim <> 2
        loop object OBJ_Monster_Base+t, animScorpWalkStart, animScorpWalkEnd
        enemy(t).CurrentAnim = 2
    endif
return

_setupClock:
    // Session variables
    clockTickCounter=0
    clockCurrentMidDot=0
    clockTicksPerSecond = maxFramerate
return

_handleClock:
    if mod(clockTickCounter*clockBlinksPerSecond, clockTicksPerSecond) = 0
        clockCurrentMidDot = 1 - clockCurrentMidDot
    endif
    
    rem TODO: for some reason, clockSpeedFactor cannot be very high, probably we cannot go faster than the framerate, otherwise we need to add more than +1 to seconds???
    if mod(clockTickCounter*clockSpeedFactor, clockTicksPerSecond) = 0
        clockSeconds = (clockSeconds + 1) mod (24*60*60)
    endif
    
    gosub _printClock

    clockTickCounter = clockTickCounter + 1
RETURN

_create_water:
    make matrix MAT_Water, cMapSizeX+2*waterMovementMaxDistance, cMapSizeZ+2*waterMovementMaxDistance, 15, 15
    load image FN_GFX_Water, IMG_Water
    prepare matrix texture MAT_Water, IMG_Water, 1, 1
    fill matrix MAT_Water, 0, 1
    position matrix MAT_Water, 0, waterLevel, 0
    ghost matrix on MAT_Water
    set matrix MAT_Water, 0, 0, 1, 1, 1, 1, 1
    update matrix MAT_Water
return

_create_floor:
    rem Boden
    make matrix MAT_Ground, cMapSizeX, cMapSizeZ, 15, 15

    load image FN_GFX_FloorTexture, IMG_ForestFloor
    prepare matrix texture MAT_Ground, IMG_ForestFloor, 1, 1
    fill matrix MAT_Ground, 0, 1
    set matrix MAT_Ground, 0, 0, 1, 1, 1, 1, 1
    randomize matrix MAT_Ground, 130
    
    rem TEST
    rem TODO: aber man kann 40,40 nicht updaten?!
    rem set matrix height MAT_Ground, 10, 10, 1000
    
    update matrix MAT_Ground
    
    remstart
    currentmatrix=1
    for z=1 to 20
        for x=1 to 20
    
          rem Get matrix heights
          rem print x, " - ", z
          rem sync
          rem sleep 100
          
          h8#=get matrix height(currentmatrix,x,z-1)
          h4#=get matrix height(currentmatrix,x-1,z)
          h#=get matrix height(currentmatrix,x,z)
          h2#=get matrix height(currentmatrix,x,z)
    
          rem Calculate projected angle X using heights
          x1#=(x-1)*25.0 : y1#=h#
          x2#=(x+0)*25.0 : y2#=h4#
          dx#=x2#-x1#
          dy#=y2#-y1#
          ax#=atanfull(dx#,dy#)
          ax#=wrapvalue(90-ax#)
    
          rem Calculate projected angle Z using heights
          z1#=(z-1)*25.0 : y1#=h2#
          z2#=(z+0)*25.0 : y2#=h8#
          dz#=z2#-z1#
          dy#=y2#-y1#
          az#=atanfull(dz#,dy#)
          az#=wrapvalue(90-az#)
    
          rem Make normal from projected angle
          nx#=sin(ax#)
          ny#=cos(ax#)
          nz#=sin(az#)
    
          rem Setting matrix normal for smoothness
          set matrix normal currentmatrix,x,z,nx#,ny#,nz#
    
       next x
    next z
    update matrix currentmatrix
    remend
return

_create_radar:
    rem Karte - Abstand zur Kamera: 1.1
    remstart
    load image FN_GFX_MapBackground, IMG_MapBackground
    make object plain OBJ_MapGhostObject, 0.352, 0.352
    lock object on OBJ_MapGhostObject
    position object OBJ_MapGhostObject, -0.6908, -0.4675, 1.1
    ghost object on OBJ_MapGhostObject
    texture object OBJ_MapGhostObject, IMG_MapBackground
    remend
    
    rem Karte - Abstand zur Kamera: 1.5
    load image FN_GFX_MapBackground, IMG_MapBackground
    make object plain OBJ_MapGhostObject, 0.48, 0.48
    lock object on OBJ_MapGhostObject
    position object OBJ_MapGhostObject, -0.942, -0.6375, 1.5
    ghost object on OBJ_MapGhostObject
    texture object OBJ_MapGhostObject, IMG_MapBackground
return

_printClock:
    if clockCurrentMidDot = 0
        middle$ = " "
    else
        middle$ = ":"
    endif
    mind = clockSeconds/60
    hours = mind/60
    if clockShowSeconds
        secsText$ = middle$+TwoDigit$(mod(clockSeconds,60))
    else
        secsText$ = ""
    endif
    print "Time: ", TwoDigit$(mod(hours,24)), middle$, TwoDigit$(mod(mind,60)), secsText$

    middle$ = ":"
    mind = surviveTill/60
    hours = mind/60
    secsText$ = ""
    print "Survive till ", TwoDigit$(mod(hours,24)), middle$, TwoDigit$(mod(mind,60)), secsText$
return

rem Rotate smooth, and rotate in the direction with the lowest distance
rem "turn object left" ist das kommando
function smoothRotate#(von#, nach#, smoothness)
    if (von# > 270) and (nach# < 90)
        ret# = WrapValue(von# + (360 - von# + nach#)/smoothness)
    else
        if (von# < 90) and (nach# > 270)
            ret# = WrapValue(von# - (360 - nach# + von#)/smoothness)
        else
            ret# = von# + (nach# - von#)/smoothness
        endif
    endif
endfunction ret#

function floorHeight#(X#, Z#)
    ret# = Get Ground Height(MAT_Ground, X#, Z#)
ENDFUNCTION ret#

function upPressed()
    ret = UpKey()=1 or keystate(17)=1 or joystick up()=1
ENDFUNCTION ret

function leftPressed()
    ret = LeftKey()=1 or keystate(30)=1 or joystick left()=1
ENDFUNCTION ret

function rightPressed()
    ret = RightKey()=1 or keystate(32)=1 or joystick right()=1
ENDFUNCTION ret

function downPressed()
    ret = DownKey()=1 or keystate(31)=1 or joystick down()=1
ENDFUNCTION ret

function jumpPressed()
    ret = keystate(57)=1 or JOYSTICK FIRE A()=1
ENDFUNCTION ret

function TwoDigit$(value)
    if value < 10
        ret$ = "0"+STR$(value)
    else
        ret$ = STR$(value)
    ENDIF
ENDFUNCTION ret$

function mod(num,modulus)
    value=num-((num/modulus)*modulus)
endfunction value

function fileReadInt(fileNum)
    read string 1, s$
    ret=val(s$)
ENDFUNCTION ret

function fileReadFloat#(fileNum)
    read string 1, s$
    ret#=val(s$)
ENDFUNCTION ret#

function RndBetween(a,b)
    ret = a+Rnd(b-a)
ENDFUNCTION ret

function isInCircle(pX#,pY#,cX#,cY#,cR#)
    ret = sqrt( (pX#-cX#)*(pX#-cX#) + (pY#-cY#)*(pY#-cY#) ) <= cR#
ENDFUNCTION ret

_stop_game_sounds:
    Stop Sound SFX_ForestBG
    Stop Sound SFX_PauseMusic
    Stop Sound SFX_Walk_Earth
    Stop Sound SFX_Walk_Water
    for t = 0 to cMaxEnemies-1
        Stop Sound SFX_Monster_Base+t
    next t
return

type treeType
   x as float
   z as float
   drawn as boolean
endtype

type enemyType
    Speed as float
    WalkTimeout as float
    WalkTimeoutMin as float
    WalkTimeoutMax as float
    AwarenessRadius as float
    CurSpeed as float
    MaxSpeed as float
    Angle as float
    CurrentAnim as float
    rem TODO: also "Drawn as boolean" to unload enemies that are too far away?
endtype

PressJumpKey:
    if onGround=1
        rem TODO: absprungsound
        JumpPosition#=floorHeight#(X#,Z#)
        velocityY# = JumpStartVelocity#
        onGround = 0
    endif
return

ReleaseJumpKey:
    if velocityY# > MinFallVelocity#
        velocityY# = MinFallVelocity#
    endif
return

JumpUpdate:
    if onGround=0
        dec velocityY#, gravity#
        inc JumpPosition#, velocityY#
        
        curFloorHeight# = floorHeight#(X#,Z#)
        if JumpPosition# < curFloorHeight#
            rem TODO: aufprallsound
            JumpPosition# = curFloorHeight#
            velocityY# = 0.0
            onGround = 1
        endif
    endif
return

function resizeImage(image as dword, width as dword, height as dword)
    if DLL EXIST(DLL_Resize32) = 0
        load dll FN_DLL_Resize32, DLL_Resize32
    endif
    
    make memblock from image MEM_ResizeSrc, image
    size = call dll(DLL_Resize32, "DestSize", get memblock ptr(MEM_ResizeSrc), width, height)
    
    rem TODO: windows 7, I get an error here that size is invalid?
    make memblock MEM_ResizeDest, size

    call dll DLL_Resize32, "Resize", get memblock ptr(MEM_ResizeSrc), get memblock ptr(MEM_ResizeDest), width, height
    
    
    make image from memblock image, MEM_ResizeDest
    
    delete memblock MEM_ResizeSrc
    delete memblock MEM_ResizeDest
    
    REM delete dll DLL_Resize

endfunction

function LoadImageFullscreen(imgFN as string, imgID)
    Load Image imgFN, imgID
    width  = screen width()
    height = image height(imgID)*screen width()/1.0/image width(imgID);
    resizeImage(imgID, width, height)
ENDFUNCTION

_play_attack_sound:
    repeat
        r=RndBetween(0,NumberOfAttackSounds-1)
    UNTIL (r <> LastAttackSound) or (NumberOfAttackSounds = 1)
    LastAttackSound=r
    play sound SFX_Attack_Base+r
return

rem -- MUST STAY AT THE END OF THE PROGRAM --
_exit:
    exit
