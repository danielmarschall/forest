rem Nightmare Forest by Daniel Marschall
rem Revision: 23 September 2025

rem ----------------------------------------------------------------

rem Important!!!
rem - When the game is minimized (Alt+Tab) and restored, it exits. Is this an error in DarkBASIC, or our fault?
rem   => When this is done during the title screen, then the following error will appear when the game is restored:
rem      "Image does not exist" at line "PASTE IMAGE IMG_TitleScreen, 0, 0"
rem      A solution would be to add "if not image exist(IMG_TitleScreen) then LoadImageFullscreen(FN_GFX_TitleScreen, IMG_TitleScreen)"
rem      at that loop. But that solves only the issue at the titlescreen. If the window is restored while the game is running,
rem      then it will crash without error message; I guess that various objects, sounds, textures have also vanished from memory?!
rem   => Also, when "set window off" and "set window on" are called, all loaded resources are gone and the game crashes
rem      This is an error with DarkBASIC! It also happens on Necropolis...

rem Nice to have:
rem - Fast walking (soil/water) sound
rem - Scorpion object speed should be adjusted so it matches the current walking speed of the enemey
rem - cleanup files and code
rem - Edge of the map with wall-graphics; attention: dark forest wall does not fit to daylight scene!
rem - Items such as map, radar, and medikit (should be spawned on waypoints generated by MapGen32)
rem - No trees should spawn around the tent

rem Enemies:
rem - rascheln im busch?
rem - scorpion schiebt stehenden spieler manchmal nicht weg?

rem MapGen32:
rem - Wegbreite konfigurierbar machen (INI)

rem Nit picking:
rem - Tree transparent edges are so ugly, as it lets you look through other trees, which makes no sense! PNG did not help.
rem - Trees have a redish shine at dawn?? why? ambient light?
rem - wenn man auf einem baum landet, kann man von dort aus nicht springen, und glitched manchmal auf dem boden
rem   ... scheinbar ist die jumpheight = 0 dann!

// --------------------------------
// Numerical Resources
// --------------------------------

#constant CAM_DEFAULT         100

#constant IMG_ForestFloor     100
#constant IMG_Water           101
#constant IMG_Tree            102
#constant IMG_TitleScreen     103
#constant IMG_DeathScreen     104

#constant OBJ_Tent            100
#constant OBJ_TreeTemplate    101
#constant OBJ_Monster_Base   1000
#constant OBJ_Tree_Base      2000

#constant MSH_TreeTemplate    100

#constant MAT_Ground          100
#constant MAT_Water           101

#constant SFX_ForestBG        100
#constant SFX_Radio           101
#constant SFX_Walk_Earth      102
#constant SFX_Walk_Water      103
#constant SFX_Woosh           104
#constant SFX_HIT_SOIL        105
#constant SFX_HIT_WATER       106
#constant SFX_Jump            107
#constant SFX_TitleMusic      109
#constant SFX_StormBG         110
#constant SFX_DeathScreen     111
#constant SFX_Attack_Base     900
#constant SFX_Monster_Base   1000

#constant DLL_ForestDLL       100

#constant MEM_Map             100
#constant MEM_ResizeSrc       101
#constant MEM_ResizeDest      102

// --------------------------------
// File names
// --------------------------------

#constant FN_DLL_ForestDLL        "ext\ForestDLL.dll"

#constant FN_SFX_ForestBG         "sound\forestbg.wav"
#constant FN_SFX_Radio            "sound\radio.wav"
#constant FN_SFX_Walk_Earth       "sound\walk_soil.wav"
#constant FN_SFX_Walk_Water       "sound\walk_water.wav"
#constant FN_SFX_Woosh            "sound\woosh.wav"
#constant FN_SFX_HIT_SOIL         "sound\hit_soil.wav"
#constant FN_SFX_HIT_WATER        "sound\hit_water.wav"
#constant FN_SFX_Jump             "sound\jump.wav"
#constant FN_SFX_ScorpionAttack1  "sound\scorp_attack1.wav"
#constant FN_SFX_ScorpionAttack2  "sound\scorp_attack2.wav"
#constant FN_SFX_ScorpionAttack3  "sound\scorp_attack3.wav"
#constant FN_SFX_ScorpionAttack4  "sound\scorp_attack4.wav"
#constant FN_SFX_TitleMusic       "music\cursed_forest.wav"
#constant FN_SFX_StormBG          "sound\stormbg.wav"
#constant FN_SFX_Deathscreen      "sound\deathscreen.wav"
#constant FN_SFX_ScorpWalk        "sound\scorp_walk.wav"

#constant FN_OBJ_ScorpIdle        "obj\scorpion\idle.dbo"
#constant FN_OBJ_ScorpWalk        "obj\scorpion\walk.dbo"
#constant FN_OBJ_Tent             "obj\tent\tent.dbo"

#constant FN_GFX_FloorTexture     "bitmap\forest_floor_texture.jpg"
#constant FN_GFX_Water            "bitmap\water.bmp"
#constant FN_GFX_Tree             "bitmap\tree.bmp"
#constant FN_GFX_TitleScreen      "bitmap\screen_background.jpg"
#constant FN_GFX_DeathScreen      "bitmap\screen_gameover.jpg"

// --------------------------------
// Read configuration
// --------------------------------

#constant COR_INITIALIZE_READ_DEFAULT 1
#constant COR_INITIALIZE_READ_USER    2
#constant COR_INITIALIZE_READ_ONCE    4
#constant COR_INITIALIZE_DELETE_ONCE  8

load dll FN_DLL_ForestDLL, DLL_ForestDLL
call DLL DLL_ForestDLL, "COR_Initialize", COR_INITIALIZE_READ_DEFAULT || COR_INITIALIZE_READ_USER || COR_INITIALIZE_READ_ONCE || COR_INITIALIZE_DELETE_ONCE

title$ = space$(256)        : call dll DLL_ForestDLL, "INI_ReadString","Product", "Title", "Nightmare Forest", title$, 256
author$ = space$(256)       : call dll DLL_ForestDLL, "INI_ReadString","Product", "Author", "Daniel Marschall", author$, 256
debugShowCoords             = call dll(DLL_ForestDLL, "INI_ReadInt",   "Game", "debugShowCoords",             0)
maxFramerate                = call dll(DLL_ForestDLL, "INI_ReadInt",   "Game", "maxFramerate",                30)
screenResW                  = call dll(DLL_ForestDLL, "INI_ReadInt",   "Game", "screenResW",                  800)
screenResH                  = call dll(DLL_ForestDLL, "INI_ReadInt",   "Game", "screenResH",                  600)
screenResB                  = call dll(DLL_ForestDLL, "INI_ReadInt",   "Game", "screenResB",                  32)
screenVSync                 = call dll(DLL_ForestDLL, "INI_ReadInt",   "Game", "screenVSync",                 0)
fullscreen                  = call dll(DLL_ForestDLL, "INI_ReadBool",  "Game", "fullscreen",                  1)
clockSpeedFactor            = call dll(DLL_ForestDLL, "INI_ReadInt",   "Game", "clockSpeedFactor",            1)
clockSecondsAdvance         = call dll(DLL_ForestDLL, "INI_ReadInt",   "Game", "clockSecondsAdvance",         60)
clockBlinksPerSecond        = call dll(DLL_ForestDLL, "INI_ReadInt",   "Game", "clockBlinksPerSecond",        2)
clockShowSeconds            = call dll(DLL_ForestDLL, "INI_ReadInt",   "Game", "clockShowSeconds",            0)
enemyRotateSmoothness       = call dll(DLL_ForestDLL, "INI_ReadInt",   "Game", "enemyRotateSmoothness",       10)
maxRunEnergy                = call dll(DLL_ForestDLL, "INI_ReadInt",   "Game", "maxRunEnergy",                300)
waterLevel                  = call dll(DLL_ForestDLL, "INI_ReadInt",   "Game", "waterLevel",                  60)
sound3dVolumeCor            = call dll(DLL_ForestDLL, "INI_ReadInt",   "Game", "sound3dVolumeCor",            3500)
invertMouse                 = call dll(DLL_ForestDLL, "INI_ReadInt",   "Game", "invertMouse",                 0)
camerarange#                = call dll(DLL_ForestDLL, "INI_ReadFloat", "Game", "camerarange",                 2000.0)
fogdistance#                = call dll(DLL_ForestDLL, "INI_ReadFloat", "Game", "fogdistance",                 1000.0)
waterMovementMaxDistance    = call dll(DLL_ForestDLL, "INI_ReadInt",   "Game", "waterMovementMaxDistance",    30)
gravity#                    = call dll(DLL_ForestDLL, "INI_ReadFloat", "Game", "gravity",                     0.6)
JumpStartVelocity#          = call dll(DLL_ForestDLL, "INI_ReadFloat", "Game", "JumpStartVelocity",           15.0)
EmergencyJumpFactor#        = call dll(DLL_ForestDLL, "INI_ReadFloat", "Game", "EmergencyJumpFactor",         1.3)
MinFallVelocity#            = call dll(DLL_ForestDLL, "INI_ReadFloat", "Game", "MinFallVelocity",             6.0)
scorpCollissionX#           = call dll(DLL_ForestDLL, "INI_ReadFloat", "Game", "scorpCollissionX",            150.0)
scorpCollissionY#           = call dll(DLL_ForestDLL, "INI_ReadFloat", "Game", "scorpCollissionY",            190.0)
scorpCollissionZ#           = call dll(DLL_ForestDLL, "INI_ReadFloat", "Game", "scorpCollissionZ",            150.0)
scorpMinDistance            = call dll(DLL_ForestDLL, "INI_ReadInt",   "Game", "scorpMinDistance",            100)
HitInterval#                = call dll(DLL_ForestDLL, "INI_ReadFloat", "Game", "HitInterval",                 5.0)
HitFactorFirst#             = call dll(DLL_ForestDLL, "INI_ReadFloat", "Game", "HitFactorFirst",              5.0)
HitFactorRecurrent#         = call dll(DLL_ForestDLL, "INI_ReadFloat", "Game", "HitFactorRecurrent",          0.1)
maxHitsTillDeath            = call dll(DLL_ForestDLL, "INI_ReadInt",   "Game", "maxHitsTillDeath",            50)
playerEyeHeight#            = call dll(DLL_ForestDLL, "INI_ReadFloat", "Game", "playerEyeHeight",             135)
cMaxTrees                   = call dll(DLL_ForestDLL, "INI_ReadInt",   "Game", "cMaxTrees",                   1200)
cMapSizeX                   = call dll(DLL_ForestDLL, "INI_ReadInt",   "Game", "cMapSizeX",                   10000)
cMapSizeZ                   = call dll(DLL_ForestDLL, "INI_ReadInt",   "Game", "cMapSizeZ",                   10000)
cTreeRadius                 = call dll(DLL_ForestDLL, "INI_ReadInt",   "Game", "cTreeRadius",                 100)
cMaxEnemies                 = call dll(DLL_ForestDLL, "INI_ReadInt",   "Game", "cMaxEnemies",                 50)
initialEnemySafezone#       = call dll(DLL_ForestDLL, "INI_ReadFloat", "Game", "InitialEnemySafezone",        1400.0)
cEnemySpawnMapBorderPadding = call dll(DLL_ForestDLL, "INI_ReadInt",   "Game", "EnemySpawnMapBorderPadding",  750)
stage1ClockStart            = call dll(DLL_ForestDLL, "INI_ReadInt",   "Game", "stage1ClockStart",            15)
stage1TinyForestFactor#     = call dll(DLL_ForestDLL, "INI_ReadFloat", "Game", "stage1TinyForestFactor",      0.35)
stage1Distance#             = call dll(DLL_ForestDLL, "INI_ReadFloat", "Game", "stage1Distance",              1450.0)
stage3ClockStart            = call dll(DLL_ForestDLL, "INI_ReadInt",   "Game", "stage3ClockStart",            22)
stage4ClockStart            = call dll(DLL_ForestDLL, "INI_ReadInt",   "Game", "stage4ClockStart",            7)
stage4RunAwayFactor#        = call dll(DLL_ForestDLL, "INI_ReadFloat", "Game", "stage4RunAwayFactor",         1.5)
nightLightLevel#            = call dll(DLL_ForestDLL, "INI_ReadFloat", "Game", "nightLightLevel",             0.0)
dayLightLevelPeak#          = call dll(DLL_ForestDLL, "INI_ReadFloat", "Game", "dayLightLevelPeak",           255.0)
sunriseStart                = call dll(DLL_ForestDLL, "INI_ReadInt",   "Game", "sunriseStart",                4)
sunsetEnd                   = call dll(DLL_ForestDLL, "INI_ReadInt",   "Game", "sunsetEnd",                   20)
runEnergyDeltaRunning#      = call dll(DLL_ForestDLL, "INI_ReadFloat", "Game", "runEnergyDeltaRunning",      -1.00)
runEnergyDeltaWalking#      = call dll(DLL_ForestDLL, "INI_ReadFloat", "Game", "runEnergyDeltaWalking",       1.00)
runEnergyDeltaSlowWalk#     = call dll(DLL_ForestDLL, "INI_ReadFloat", "Game", "runEnergyDeltaSlowWalk",      1.25)
runEnergyDeltaStanding#     = call dll(DLL_ForestDLL, "INI_ReadFloat", "Game", "runEnergyDeltaStanding",      1.50)
speedBoostWalking#          = call dll(DLL_ForestDLL, "INI_ReadFloat", "Game", "speedBoostWalking",           1.0)
speedBoostRunning#          = call dll(DLL_ForestDLL, "INI_ReadFloat", "Game", "speedBoostRunning",           2.0)
speedBoostSlowWalk#         = call dll(DLL_ForestDLL, "INI_ReadFloat", "Game", "speedBoostSlowWalk",          0.5)

rem Some fixes to the configuration to over errors due to wrong values
if cMaxEnemies > OBJ_Tree_Base-OBJ_Monster_Base then cMaxEnemies = OBJ_Tree_Base-OBJ_Monster_Base
if stage3ClockStart < stage1ClockStart then stage3ClockStart = stage3ClockStart + 24
if stage4ClockStart < stage3ClockStart then stage4ClockStart = stage4ClockStart + 24

rem These are some variables required for the tent
rem It makes no sense to add them to the INI file, I think.
tentDryRadius = 120
tentSizeX     = 20000
tentSizeY     = 15000
tentSizeZ     = 10000
tentMoveX     = 0
tentMoveY     = -30
tentMoveZ     = 0
tentRotateX   = 0
tentRotateY   = 180
tentRotateZ   = 0
tentCameraDistanceStage4 = 60
tentMinTreeDistance = 400

set display mode screenResW, screenResH, screenResB, screenVSync
if fullscreen = 0
    set window on
    set window title title$
    set window position int(desktop width()/2 - screen width()/2), int(desktop height()/2 - screen height()/2)
else
    set window off
endif

hide mouse

Sync On
Sync Rate maxFramerate

rem Sync twice at application start for friendliness with dbpro's double buffering
rem (Required for newer versions of DB Pro)
sync : sync

load sound FN_SFX_TitleMusic, SFX_TitleMusic

gosub _show_legend

rem ink rgb(255, 230, 0), 0
rem PASTE IMAGE IMG_TitleScreen, 0, 0
rem set text font "Arial" : set text size 30 : set text transparent
rem text 28, 550, "Starting game..."

randomize timer()

draw to front

gosub _init_working_variables
gosub _setup_camera
gosub _create_floor
gosub _create_tent
gosub _create_trees : rem Requires tent to be created
gosub _create_water

gosub _draw_trees

load sound FN_SFX_StormBG,         SFX_StormBG
load sound FN_SFX_ForestBG,        SFX_ForestBG
load sound FN_SFX_Walk_Earth,      SFX_Walk_Earth
load sound FN_SFX_Walk_Water,      SFX_Walk_Water
load sound FN_SFX_Woosh,           SFX_Woosh
load sound FN_SFX_Hit_Soil,        SFX_Hit_Soil
load sound FN_SFX_Hit_Water,       SFX_Hit_Water
load sound FN_SFX_Jump,            SFX_Jump
load sound FN_SFX_DeathScreen,     SFX_DeathScreen

#constant NumberOfAttackSounds 4
load sound FN_SFX_ScorpionAttack1, SFX_Attack_Base+0
load sound FN_SFX_ScorpionAttack2, SFX_Attack_Base+1
load sound FN_SFX_ScorpionAttack3, SFX_Attack_Base+2
load sound FN_SFX_ScorpionAttack4, SFX_Attack_Base+3

LoadImageFullscreen(FN_GFX_DeathScreen, IMG_DeathScreen)

rem Rebuild screen
cls
sync

Disable EscapeKey

rem Main loop
do
    if fullscreen = 0 then position mouse int(screen width()/2), int(screen height()/2)
    gosub _handle_weather
    gosub _handle_player
    gosub _update_trees
    gosub _handle_stage
    gosub _handle_enemies
    gosub _handle_clock
    gosub _update_hud
    if hits >= maxHitsTillDeath then gosub _deathscreen
    if EscapeKey() = 1
        repeat
            sync
        until not (EscapeKey() = 1)
        gosub _pausemenu
    endif
    sync
loop

rem ----------------------------------------------------------------

_init_working_variables:
    JumpKeyStatePrev = 0
    JumpPosition# = 0.0
    onGround = 1
    velocityY# = 0.0
    runEnergy# = maxRunEnergy
    prevTreeStage = -1
    stage = 0
    clockSeconds = -1
    collcounter# = 0.0
    hits = 0
    LastAttackSound = 0
    fogColorR = 0
    fogColorG = 0
    fogColorB = 0
    underAttack = 0
    attackHudColorStrength = 0
    clockTickCounter=0
    clockCurrentMidDot=0
    clockTicksPerSecond = maxFramerate
return

_show_legend:
    LoadImageFullscreen(FN_GFX_TitleScreen, IMG_TitleScreen)

    loop sound SFX_TitleMusic

    tmp = 0
    repeat
        cls

        PASTE IMAGE IMG_TitleScreen, 0, 0

        ink rgb(255, 100, 0), 0
        set text font "Arial" : set text size 50 : set text transparent
        print "The Tale of the " + title$

        set text font "Arial" : set text size 30 : set text transparent
        print ""
        print "They say there's a grove outside the village."
        print "By day it's small, nothing more than a patch of trees."
        print "But when night falls, it opens into a forest without end."
        print ""
        print "A few have gone in after dark. None came back."
        print "The elders whisper the forest doesn't lose you -"
        print "it keeps you."
        print ""
        print "And each soul it takes makes the grove a little"
        print "larger by morning."
        print ""
        print "Today you've set up your tent below the trees,"
        print "waiting for nightfall... to see if the legend is true."
        print ""
        set text font "Arial" : set text size 23 : set text transparent
        print ""
        print "Press Space to start your journey."
        print "Controls: WASD for walking and mouse for looking around,"
        print "Space for jumping (press longer for higher jump),"
        print "Hold Ctrl for running (not while being in water),"
        print "Hold Shift for walking slowly (refills run energy faster)"

        sync

        if (tmp = 0) and (jumpPressed() = 1)
            tmp = 1
        else
            if (tmp = 1) and (jumpPressed() = 0)
                tmp = 2
            endif
        endif
    until tmp = 2
return

_update_hud:
    ink rgb(255, 100, 0), 0
    set text font "Arial" : set text size 30 : set text transparent

    runEnergyPercent# = runEnergy#*100.0/maxRunEnergy
    print "Run Energy: ", Floor(runEnergyPercent#), "%"

    health# = 100.0 - hits*100.0/maxHitsTillDeath
    print "Health: ", Floor(health#), "%"

    if clockCurrentMidDot = 0
        middle$ = " "
    else
        middle$ = ":"
    endif
    mind = clockSeconds/60
    hours = mind/60
    if clockShowSeconds
        secsText$ = middle$+TwoDigit$(mod(clockSeconds,60))
    else
        secsText$ = ""
    endif
    print "Time: ", TwoDigit$(mod(hours,24)), middle$, TwoDigit$(mod(mind,60)), secsText$

    if stage = 1
        print "Rest in the tent!"
    else
        if stage = 2
            print "Waiting for the night..."
        else
            if stage = 3
                middle$ = ":"
                surviveTill = (stage4ClockStart*60*60) mod (24*60*60)
                mind = surviveTill/60
                hours = mind/60
                secsText$ = ""
                print "Survive till ", TwoDigit$(mod(hours,24)), middle$, TwoDigit$(mod(mind,60)), secsText$
            else
                if stage = 4
                    print "You survived! Escape from the forest!"
                endif
            endif
        endif
    endif

    if debugShowCoords = 1 then print "DEBUG Coords: X", X#, " / Y", Y#, " / Z", Z#
return

_handle_stage:
    if stage = 0
        stage = 1
        gosub _setup_player_position
        clockSeconds = stage1ClockStart*60*60
        rem Move the camera so we can see the tiny forest; TODO: we could end up at a tree!
        move camera CAM_DEFAULT, -stage1Distance#
        X# = camera position x(CAM_DEFAULT)
        Y# = camera position y(CAM_DEFAULT)
        Z# = camera position z(CAM_DEFAULT)

        loop sound SFX_StormBG
        loop sound SFX_Radio
    else
        if stage = 1
            rem dx# = abs(object position x(OBJ_Tent) - camera position x(CAM_DEFAULT))
            rem dy# = abs(object position y(OBJ_Tent) - camera position y(CAM_DEFAULT))
            rem dz# = abs(object position z(OBJ_Tent) - camera position z(CAM_DEFAULT))
            rem if dx# < 300 and dy# < 300 and dz# < 300
            rx# = object position x(OBJ_Tent)
            ry# = object position y(OBJ_Tent)
            rz# = object position z(OBJ_Tent)
            if IsInCircle3D(rx#, ry#, rz#, X#, Y#, Z#, 300) = 1
                gosub _stop_game_sounds_keep_background
                stage = 2
            endif
        else
            if stage = 2
                if clockSeconds < stage3ClockStart*60*60
                    rem Advance in 5-minute steps until it is night (stage 3)
                    clockSeconds = clockSeconds + 60*5
                else
                    stop sound SFX_TitleMusic
                    stop sound SFX_StormBG
                    play sound SFX_Woosh
                    loop sound SFX_ForestBG
                    loop sound SFX_Radio
                    gosub _create_enemies
                    clockSeconds = stage3ClockStart*60*60
                    stage = 3
                endif
            else
                if stage = 3
                    if clockSeconds >= stage4ClockStart*60*60
                        gosub _destroy_enemies
                        rem Quickly teleport to the tent, so that the player do not notice it
                        position camera CAM_DEFAULT, object position x(OBJ_Tent), object position y(OBJ_Tent), object position z(OBJ_Tent)
                        rem move the camera and pause for a little while so that the player realizes the tent; TODO: we could end up at a tree!
                        move camera  CAM_DEFAULT, -tentCameraDistanceStage4
                        sync

                        stop sound SFX_ForestBG
                        play sound SFX_Woosh

                        sleep 1000
                        X# = camera position x(CAM_DEFAULT)
                        Y# = camera position y(CAM_DEFAULT)
                        Z# = camera position z(CAM_DEFAULT)
                        stage = 4

                        loop sound SFX_TitleMusic
                        loop sound SFX_StormBG
                    endif
                else
                    if stage = 4
                        rx# = object position x(OBJ_Tent)
                        rz# = object position z(OBJ_Tent)
                        incircle = IsInCircle(rx#, rz#, X#, Z#, stage1Distance#*stage4RunAwayFactor#)
                        if incircle = 0 then gosub _winscreen
                    endif
                endif
            endif
        endif
    endif
return

_destroy_enemies:
    for t = 0 to cMaxEnemies-1
        Delete Object OBJ_Monster_Base+t
        Stop Sound SFX_Monster_Base+t
        Delete Sound SFX_Monster_Base+t
        enemy(t).IsAttacking = 0
    next t
    underAttack = 0
return

_pausemenu:
    if stage = 3
        gosub _stop_game_sounds_keep_background
        loop sound SFX_TitleMusic
    else
        gosub _stop_game_sounds_keep_background
    endif

    tmp=0
    repeat
        cls

        paste image IMG_TitleScreen, 0, 0

        ink rgb(255,255,255),1
        text 28, 550, "Pause. ESC=Continue. DownKey=End."
        sync

        if DownKey() = 1
            goto _exit
        ENDIF

        if (tmp = 0) and (EscapeKey() = 1)
            tmp = 1
        else
            if (tmp = 1) and (EscapeKey() = 0)
                tmp = 2
            endif
        endif
    until tmp = 2

    if stage = 3
        stop sound SFX_TitleMusic
        loop sound SFX_ForestBG
        loop sound SFX_Radio
    endif
return

_deathscreen:
    enable escapekey

    gosub _stop_game_sounds
    play sound SFX_DeathScreen

    tmp=TIMER()
    repeat
        cls
        paste image IMG_DeathScreen, 0, 0
        sync
    until abs(TIMER()-tmp) >= 5000

    rem We could either exit the game ...
    rem goto _exit

    rem ... or continue another round
    Disable EscapeKey
    gosub _destroy_enemies
    gosub _init_working_variables
    gosub _stop_game_sounds
    loop sound SFX_TitleMusic
return

_winscreen:
    enable escapekey

    gosub _stop_game_sounds_keep_background

    tmp=TIMER()
    repeat
        cls
        paste image IMG_TitleScreen, 0, 0
        ink rgb(255,255,255),1
        text 100,140,"Thank you for playing " + title$ + " !"
        text 100,180,"Created by " + author$ + " 2001 - 2025"
        text 100,220,"Developed with DarkBASIC Pro and Delphi"
        sync
    until abs(TIMER()-tmp) >= 7500

    rem We could either exit the game ...
    goto _exit

    rem ... or continue another round
    remstart
    Disable EscapeKey
    gosub _init_working_variables
    gosub _stop_game_sounds
    loop sound SFX_TitleMusic
    remend
return

_setup_camera:
    if CAM_DEFAULT <> 0 then Make Camera CAM_DEFAULT
    Set camera range CAM_DEFAULT, 1, camerarange#
    AUTOMATIC CAMERA COLLISION CAM_DEFAULT, collissionboxsize#, 0 : rem TODO: scorpione stoßen den spieler nicht weg, wenn keine taste gedrückt wird? syntax mit 4 parametern funktioniert im neuen dbpro free nicht!
    Autocam off
return

_create_tent:
    tentX# = cMapSizeX / 2 + tentMoveY
    tentZ# = cMapSizeZ / 2 + tentMoveZ
    tentY# = floorHeight#(tentX#, tentZ#) + tentMoveY

    Load object FN_OBJ_Tent, OBJ_Tent
    show object OBJ_Tent
    scale object OBJ_Tent, tentSizeX, tentSizeY, tentSizeZ
    rotate object  OBJ_TENT, tentRotateX, tentRotateY, tentRotateZ
    position object OBJ_Tent, tentX#, tentY#, tentZ#

    if not sound exist(SFX_Radio)
        rem NOTE: 3DSound requires Mono audio!
        Load 3Dsound FN_SFX_Radio, SFX_Radio
        rem TODO: also use sound3dVolumeCor, like for the scorpions?
        Position Sound SFX_Radio, tentX#, tentY#, tentZ#
    endif

    rem TODO: for some reason, the tent does not react to light. the scorpions do, but the trees, tent, and floor do not. why?!
    remstart
    set ambient light 50
    set object light OBJ_TENT, 1
    set object normals OBJ_Tent
    set object effect OBJ_Tent, 0
    make light 1
    color light 1,255,255,200
    set point light 1, object position x(OBJ_TENT), object position y(OBJ_TENT)+600, object position z(OBJ_TENT)
    set light range 1,3000
    show light 1
    remend
return

_setup_player_position:
    X# = cMapSizeX / 2
    Y# = floorHeight#(X#, Z#) + playerEyeHeight
    Z# = cMapSizeZ / 2
    position camera CAM_DEFAULT, X#, Y#, Z#
return

_handle_weather:
    clockSecondsReal = clockSeconds mod (24*60*60)
    if clockSecondsReal < (sunriseStart*3600) or clockSecondsReal > (sunsetEnd*3600)
        lightValue = INT(nightLightLevel# + 0.5)
    else
        rem gesamte Tagesspanne von Dämmerungsbeginn bis -ende
        daySpanStart = (sunriseStart*3600)
        daySpanEnd   = (sunsetEnd*3600)

        duration# = (daySpanEnd - daySpanStart) * 1.0    : rem float-sicher
        u# = (clockSecondsReal - daySpanStart) / duration#   : rem 0..1
        if u# < 0.0 then u# = 0.0
        if u# > 1.0 then u# = 1.0

        rem Sinuskurve: 0 am Dämmerungsbeginn, 1 in der Mitte (Mittag), 0 am Dämmerungsende
        daylightFactor# = sin(u# * 180)

        rem Auf Zielbereich (nightLightLevel# .. dayLightLevelPeak#) skalieren
        lightValue# = nightLightLevel# + daylightFactor# * (dayLightLevelPeak# - nightLightLevel#)

        rem numerische Sicherheit & auf 0..255 clampen
        if lightValue# < 0.0 then lightValue# = 0.0
        if lightValue# > 255.0 then lightValue# = 255.0

        lightValue = INT(lightValue# + 0.5)
    endif
    rem print "DEBUG: clockSecondsReal:", clockSecondsReal, " => lightValue:", lightValue#

    fogColorR = lightValue
    fogColorG = lightValue
    fogColorB = lightValue

    if underAttack > 0
        attackHudColorStrength = attackHudColorStrength + 10
        if attackHudColorStrength > 255 then attackHudColorStrength = 255
    else
        attackHudColorStrength = attackHudColorStrength - 10
        if attackHudColorStrength < 0 then attackHudColorStrength = 0
    endif

    fogColorR = fogColorR + attackHudColorStrength
    if fogColorR > 255 then fogColorR = 255

    fogColorG = fogColorG - attackHudColorStrength
    if fogColorG < 0 then fogColorG = 0

    fogColorB = fogColorB - attackHudColorStrength
    if fogColorB < 0 then fogColorB = 0

    backdrop on CAM_DEFAULT
    color backdrop CAM_DEFAULT, rgb(fogColorR, fogColorG, fogColorB)

    if fog available() = 1
        fog on
        fog distance fogdistance#
        fog color rgb(fogColorR, fogColorG, fogColorB)
    endif

    rem Water movement
    waterdir = (waterdir + 1) mod 360;
    watermov = 0 + cos(waterdir)*waterMovementMaxDistance
    position matrix MAT_Water, watermov, waterLevel, watermov
return

_handle_enemies:
    pX# = Camera Position X(CAM_DEFAULT)
    pZ# = Camera Position Z(CAM_DEFAULT)

    if stage = 3
        underAttack = 0
        for t = 0 to cMaxEnemies-1
            rem rx# = object position x(OBJ_Monster_Base+t)
            rem ry# = object position y(OBJ_Monster_Base+t)
            rem rz# = object position z(OBJ_Monster_Base+t)
            rem if IsInCircle3D(rx#, ry#, rz#, X#, Y#, Z#, scorpCollissionZ#) = 1
            dx# = abs(object position x(OBJ_Monster_Base+t) - camera position x(CAM_DEFAULT))
            dy# = abs(object position y(OBJ_Monster_Base+t) - camera position y(CAM_DEFAULT))
            dz# = abs(object position z(OBJ_Monster_Base+t) - camera position z(CAM_DEFAULT))
            if dx# < scorpCollissionX# and dy# < scorpCollissionY# and dz# < scorpCollissionZ#
                underAttack = underAttack + 1
                if enemy(t).IsAttacking = 1
                    rem Recurrent attacks cause slower damage than the first hit
                    collcounter# = collcounter# + HitFactorRecurrent#
                else
                    collcounter# = collcounter# + HitFactorFirst#
                endif
                enemy(t).IsAttacking = 1
            else
                enemy(t).IsAttacking = 0
            endif

            eX# = Object Position X(OBJ_Monster_Base+t)
            eY# = Object Position Y(OBJ_Monster_Base+t)
            eZ# = Object Position Z(OBJ_Monster_Base+t)

            eRX# = Object Angle X(OBJ_Monster_Base+t)
            eRY# = Object Angle Y(OBJ_Monster_Base+t)
            eRZ# = Object Angle Z(OBJ_Monster_Base+t)

            deltaX# = pX#-eX#
            deltaZ# = pZ#-eZ#

            dist# = sqrt( deltaX#*deltaX# + deltaZ#*deltaZ# )

            if not sound playing(SFX_Monster_Base+t)
                set sound volume SFX_Monster_Base+t, 0
                loop sound SFX_Monster_Base+t
            endif

            rem The mixing of 3dsound is bullshit (too loud from far distance, and not very loud on close distance),
            rem so we mix the volume ourself
            if sound3dVolumeCor>0 and dist#<sound3dVolumeCor then set sound volume SFX_Monster_Base+t, (1-(dist#/sound3dVolumeCor))*100

            if dist# > scorpMinDistance
                if dist# < enemy(t).AwarenessRadius
                    rem If you are close enough (to their awareness radius), they will follow you
                    enemy(t).Angle = atanfull(deltaX#, deltaZ#)
                    enemy(t).Angle = WrapValue(enemy(t).Angle+180)
                    if (underAttack=1) and (onGround=0)
                        rem If you are under attack and jumping away from them, they will stop (otherwise the game would be too hard)
                        enemy(t).CurSpeed = 0
                    else
                        rem Otherwise, they will follow you with max speed
                        enemy(t).CurSpeed = enemy(t).MaxSpeed
                    endif
                else
                    if enemy(t).WalkTimeout <= 0
                        enemy(t).WalkTimeout = RndBetween(enemy(t).WalkTimeoutMin, enemy(t).WalkTimeoutMax)
                        enemy(t).Angle = RndBetween(0,359)
                        enemy(t).CurSpeed = RndBetween(0, enemy(t).MaxSpeed)
                    ENDIF
                    enemy(t).WalkTimeout = enemy(t).WalkTimeout - 1
                endif

                if enemy(t).CurSpeed = 0
                    gosub scorpChangeToIdle
                else
                    gosub scorpChangeToWalk
                endif

                a# = WrapValue(enemy(t).Angle + 180)
                XTest# = Newxvalue(eX#, a#, enemy(t).CurSpeed)
                ZTest# = Newzvalue(eZ#, a#, enemy(t).CurSpeed)
                if XTest# > 0 and XTest# < cMapSizeX then eX# = XTest#
                if ZTest# > 0 and ZTest# < cMapSizeZ then eZ# = ZTest#
                if XTest# <= 0 or XTest# >= cMapSizeX or ZTest# <= 0 or ZTest# >= cMapSizeZ
                    rem Kehrtwende, um den Kartenrand zu verlassen
                    enemy(t).Angle = WrapValue(enemy(t).Angle+180)
                    enemy(t).WalkTimeout = RndBetween(enemy(t).WalkTimeoutMin, enemy(t).WalkTimeoutMax)
                    enemy(t).CurSpeed = RndBetween(0, enemy(t).MaxSpeed)
                endif

                eY# = floorHeight#(eX#, eZ#)
                Position Object OBJ_Monster_Base+t, eX#, eY#, eZ#
                Position Sound SFX_Monster_Base+t, eX#, eY#, eZ#

                eRY# = smoothRotate#(eRY#, enemy(t).Angle, enemyRotateSmoothness)
                rotate object OBJ_Monster_Base+t, eRX#, eRY#, eRZ#
            endif
        next t
    endif

    if underAttack = 0
        collcounter# = collcounter# - 1.0
        if collcounter# < 0.0 then collcounter# = 0.0
    endif

    if collcounter# >= HitInterval#
        collcounter# = 0.0
        inc hits, 1
        gosub _play_attack_sound
    endif
return

#constant GROUNDTYPE_AIR 0
#constant GROUNDTYPE_EARTH 1
#constant GROUNDTYPE_WATER 2
rem #constant GROUNDTYPE_DEEPWATER 3
function groundType(onGround, waterLevel)
    if onGround = 0
        ret = GROUNDTYPE_AIR
    else
        X# = camera position x(CAM_DEFAULT)
        Z# = camera position z(CAM_DEFAULT)
        if floorHeight#(X#,Z#) > waterLevel
            ret = GROUNDTYPE_EARTH
        else
            ret = GROUNDTYPE_WATER
        endif
    endif
endfunction ret

_handle_player:
    set cursor 0, 0
    oldcAY# = cAY#
    oldcAX# = cAX#

    if (stage <> 0) and (stage <> 2)

        X# = camera position x(CAM_DEFAULT)
        Y# = camera position y(CAM_DEFAULT)
        Z# = camera position z(CAM_DEFAULT)

        if invertMouse = 1
            cAX# = WrapValue(cAX# - MousemoveY() * 0.2)
        else
            cAX# = WrapValue(cAX# + MousemoveY() * 0.2)
        endif
        cAY# = WrapValue(cAY# + MousemoveX() * 0.2)
        cAZ# = Camera angle Z(CAM_DEFAULT)

        rem Sprungroutine
        rem TODO: + Anlaufsprung

        JumpKeyStateNow=jumpPressed()
        if (JumpKeyStatePrev=0) and (JumpKeyStateNow=1)
            gosub PressJumpKey
        ENDIF
        if (JumpKeyStatePrev=1) and (JumpKeyStateNow=0)
            gosub ReleaseJumpKey
        ENDIF
        JumpKeyStatePrev = JumpKeyStateNow
        gosub JumpUpdate

        rem Laufen
        speedboost# = speedBoostWalking#

        gt = groundType(onGround, waterLevel)

        if upPressed()+downPressed()+leftPressed()+rightPressed() = 0
            runEnergy# = runEnergy# + runEnergyDeltaStanding#
            stop sound SFX_Walk_Earth
            stop sound SFX_Walk_Water
        else
            if gt = GROUNDTYPE_EARTH
                stop sound SFX_Walk_Water
                if not sound playing(SFX_Walk_Earth)
                    loop sound SFX_Walk_Earth
                endif
            endif
            if gt = GROUNDTYPE_WATER
                stop sound SFX_Walk_Earth
                if not sound playing(SFX_Walk_Water)
                    loop sound SFX_Walk_Water
                endif
            endif
            if gt = GROUNDTYPE_AIR
                stop sound SFX_Walk_Earth
                stop sound SFX_Walk_Water
            endif

            energyChanged = 0
            if ShiftKey()+ControlKey() = 1 : rem shift+control at the same time would result in 2. We want that they walk normal then, so we check for =1.
                rem TODO: es ruckelt trotzdem noch
                if ControlKey()=1 and runEnergy#>0 and gt=GROUNDTYPE_EARTH : rem Energy >1 , damit es nicht ruckelt (run-walk-run-walk-run-walk) . 3 = walk regain
                    speedboost# = speedBoostRunning#
                    runEnergy# = runEnergy# + runEnergyDeltaRunning# : rem Note: runEnergyDeltaRunning# is usually negative, so "+" is correct
                    energyChanged = 1
                endif
                if ShiftKey()=1
                    speedboost# = speedBoostSlowWalk#
                    runEnergy# = runEnergy# + runEnergyDeltaSlowWalk#
                    energyChanged = 1
                endif
            endif
            rem If we were neither running, nor slow walking, then we are walking normally
            if energyChanged = 0 then runEnergy# = runEnergy# + runEnergyDeltaWalking#

            if upPressed()
                XTest# = Newxvalue(X#, cAY#, 7*speedboost#)
                ZTest# = Newzvalue(Z#, cAY#, 7*speedboost#)
                gosub _WorldBoundCheck
            endif
            if downPressed()
                XTest# = Newxvalue(X#, Wrapvalue(cAY# - 180), 5*(speedboost#/2))
                ZTest# = Newzvalue(Z#, Wrapvalue(cAY# - 180), 5*(speedboost#/2))
                gosub _WorldBoundCheck
            endif
            if leftPressed()
                XTest# = Newxvalue(X#, Wrapvalue(cAY# - 90), 5*(speedboost#/1.3))
                ZTest# = Newzvalue(Z#, Wrapvalue(cAY# - 90), 5*(speedboost#/1.3))
                gosub _WorldBoundCheck
            endif
            if rightPressed()
                XTest# = Newxvalue(X#, Wrapvalue(cAY# + 90), 5*(speedboost#/1.3))
                ZTest# = Newzvalue(Z#, Wrapvalue(cAY# + 90), 5*(speedboost#/1.3))
                gosub _WorldBoundCheck
            endif
        endif
        if runEnergy# > maxRunEnergy then runEnergy# = maxRunEnergy

        Rem Rotate camera
        cTestX# = WrapValue(cAX# - 180)
        if cTestX# > 225 then cAX# = 45
        if cTestX# < 135 then cAX# = 315
        YRotate camera CAM_DEFAULT, CurveAngle(cAY#, oldcAY#, 24)
        XRotate camera CAM_DEFAULT, CurveAngle(cAX#, oldcAX#, 24)

        Rem Position Camera
        if onGround=1
            Y#=floorHeight#(X#, Z#)
        else
            Y#=JumpPosition#
        ENDIF
        inc Y#, playerEyeHeight#
        Position Camera CAM_DEFAULT, X#, Y#, Z#

        Rem Position Listener
        Position Listener X#, Y#, Z#
        Rotate Listener cAX#, cAY#, cAZ#

        rem if onGround = 0
        rem     jumpheight#=Y#-FloorHeight#(X#,Z#)
        rem else
        rem     jumpheight#=0
        rem endif
    endif

return

_WorldBoundCheck:
    if stage = 1
        rx# = object position x(OBJ_Tent)
        rz# = object position z(OBJ_Tent)
        if IsInCircle(rx#, rz#, XTest#, ZTest#, stage1Distance#*stage4RunAwayFactor#)
            X# = XTest#
            Z# = ZTest#
        else
            Print ""
            Print "Wrong Direction! Rest in the Tent!"
            Print ""
        endif
    else
        if XTest# > 0 and XTest# < cMapSizeX then X# = XTest#
        if ZTest# > 0 and ZTest# < cMapSizeZ then Z# = ZTest#
    endif
return

_update_trees:
    if (ceil(X#) mod 10 = 0) or (ceil(Z#) mod 10 = 0) or (stage<>prevTreeStage)
        for t = 0 to cMaxTrees-1
            rx# = tree(t).x
            rz# = tree(t).z
            if stage = 3
                rem Large forest (extending automatically)
                incircle = IsInCircle(rx#, rz#, X#, Z#, camerarange#)
            else
                rem Tiny forest around tent (stay fixed)
                incircle = IsInCircle(rx#, rz#, object position x(OBJ_TENT), object position z(OBJ_TENT), camerarange#*stage1TinyForestFactor#)
            endif
            if incircle <> tree(t).drawn
                if incircle = 1
                    incircle = IsInCircle(rx#, rz#, object position x(OBJ_TENT), object position z(OBJ_TENT), tentMinTreeDistance)
                    if incircle = 0
                        if object exist(OBJ_Tree_Base+t)
                            show object OBJ_Tree_Base+t
                        else
                            make object OBJ_Tree_Base+t, MSH_TreeTemplate, IMG_Tree
                            position object OBJ_Tree_Base+t, rx#, floorHeight#(rx#, rz#)+190, rz#
                            set object OBJ_Tree_Base+t, 1, 1, 0
                            rotate object OBJ_Tree_Base+t, 0, RndBetween(0,359), 0
                        endif
                        tree(t).drawn = 1
                    else
                        delete object OBJ_Tree_Base+t
                        rem hide object OBJ_Tree_Base+t
                        tree(t).drawn = 0
                    endif
                else
                    delete object OBJ_Tree_Base+t
                    rem hide object OBJ_Tree_Base+t
                    tree(t).drawn = 0
                endif
            endif
        next t
        prevTreeStage = stage
    endif
return

_draw_trees:
    load image FN_GFX_Tree, IMG_Tree

    make object plain OBJ_TreeTemplate, 2*cTreeRadius, 400
    make mesh from object MSH_TreeTemplate, OBJ_TreeTemplate
    add limb OBJ_TreeTemplate, 1, MSH_TreeTemplate
    rotate limb OBJ_TreeTemplate, 1, 0, 90, 0
    make mesh from object MSH_TreeTemplate, OBJ_TreeTemplate
    delete object OBJ_TreeTemplate
return

_create_trees:
    dim tree(cMaxTrees-1) as treeType

    call dll DLL_ForestDLL, "MAP_LoadParameters" : rem This will internally also call MAP_RandomSeed or MAP_UseSeed

    make memblock MEM_Map, cMaxTrees*8
    call dll DLL_ForestDLL, "MAP_GenerateMap", cMaxTrees, cTreeRadius, cMapSizeX, cMapSizeZ, get memblock ptr(MEM_Map), 0
    for t = 0 to cMaxTrees-1
        tree(t).x = memblock dword(MEM_Map, t*8)
        tree(t).z = memblock dword(MEM_Map, t*8+4)
        tree(t).drawn = 0
    next t
    delete memblock MEM_Map
return

_create_enemies:
    dim enemy(cMaxEnemies-1) as enemyType
    for t = 0 to cMaxEnemies-1
        enemy(t).Speed = 0.0
        enemy(t).WalkTimeout = 0.0
        enemy(t).WalkTimeoutMin = 0.0
        enemy(t).WalkTimeoutMax = 0.0
        enemy(t).AwarenessRadius = 0.0
        enemy(t).CurSpeed = 0.0
        enemy(t).MaxSpeed = 0.0
        enemy(t).Angle = 0.0
        enemy(t).CurrentAnim = 0.0
        enemy(t).IsAttacking = 0

        if t=0
            rem NOTE: 3DSound requires Mono audio!
            Load 3Dsound FN_SFX_ScorpWalk, SFX_Monster_Base+t
        else
            Clone Sound SFX_Monster_Base+t, SFX_Monster_Base
        endif

        pX# = Camera Position X(CAM_DEFAULT)
        pY# = Camera Position Y(CAM_DEFAULT)
        pZ# = Camera Position Z(CAM_DEFAULT)

        repeat
            eX# = RndBetween(cEnemySpawnMapBorderPadding, cMapSizeX-cEnemySpawnMapBorderPadding)
            eZ# = RndBetween(cEnemySpawnMapBorderPadding, cMapSizeZ-cEnemySpawnMapBorderPadding)
            deltaX# = pX#-eX#
            deltaZ# = pZ#-eZ#
            dist# = sqrt( deltaX#*deltaX# + deltaZ#*deltaZ# )
            rem Prevent that the enemies spawn right at the player (5000/5000)
        until dist# >= initialEnemySafezone#
        enemy(t).AwarenessRadius = RndBetween(600, 1300)
        enemy(t).MaxSpeed = RndBetween(1, 4)
        enemy(t).WalkTimeoutMin = 200
        enemy(t).WalkTimeoutMax = 300

        if t = 0
            animScorpIdleStart = 0
            Load object FN_OBJ_ScorpIdle, OBJ_Monster_Base+t
            animScorpIdleEnd = total object frames(OBJ_Monster_Base+t)

            animScorpWalkStart = animScorpIdleEnd+1
            Append object FN_OBJ_ScorpWalk, OBJ_Monster_Base+t, animScorpWalkStart
            animScorpWalkEnd = total object frames(OBJ_Monster_Base+t)
        else
            Clone Object OBJ_Monster_Base+t, OBJ_Monster_Base
            rem Instance Object OBJ_Monster_Base+t, OBJ_Monster_Base
        endif

        eY# = floorHeight#(eX#, eZ#)
        position object OBJ_Monster_Base+t, eX#, eY#, eZ#
        Position Sound SFX_Monster_Base+t, eX#, eY#, eZ#

        fix object pivot OBJ_Monster_Base+t
        gosub scorpChangeToWalk
        set object collision on OBJ_Monster_Base+t
    next t
return

scorpChangeToIdle:
    if enemy(t).CurrentAnim <> 1
        loop object OBJ_Monster_Base+t, animScorpIdleStart, animScorpIdleEnd
        enemy(t).CurrentAnim = 1
    endif
return

scorpChangeToWalk:
    if enemy(t).CurrentAnim <> 2
        loop object OBJ_Monster_Base+t, animScorpWalkStart, animScorpWalkEnd
        enemy(t).CurrentAnim = 2
    endif
return

_handle_clock:
    if mod(clockTickCounter*clockBlinksPerSecond, clockTicksPerSecond) = 0
        clockCurrentMidDot = 1 - clockCurrentMidDot
    endif

    if stage = 3
        rem TODO: for some reason, clockSpeedFactor cannot be very high, probably we cannot go faster than the framerate, otherwise we need to add more than +1 to seconds???
        if mod(clockTickCounter*clockSpeedFactor, clockTicksPerSecond) = 0
            clockSeconds = clockSeconds + clockSecondsAdvance
        endif
    endif

    clockTickCounter = clockTickCounter + 1
RETURN

_create_water:
    make matrix MAT_Water, cMapSizeX+2*waterMovementMaxDistance, cMapSizeZ+2*waterMovementMaxDistance, 15, 15
    load image FN_GFX_Water, IMG_Water
    prepare matrix texture MAT_Water, IMG_Water, 1, 1
    fill matrix MAT_Water, 0, 1
    position matrix MAT_Water, 0, waterLevel, 0
    ghost matrix on MAT_Water
    set matrix MAT_Water, 0, 0, 1, 1, 1, 1, 1
    update matrix MAT_Water
return

_create_floor:
    rem Boden
    make matrix MAT_Ground, cMapSizeX, cMapSizeZ, 15, 15

    load image FN_GFX_FloorTexture, IMG_ForestFloor
    prepare matrix texture MAT_Ground, IMG_ForestFloor, 1, 1
    fill matrix MAT_Ground, 0, 1
    set matrix MAT_Ground, 0, 0, 1, 1, 1, 1, 1

    repeat
        randomize matrix MAT_Ground, 130
        update matrix MAT_Ground

        tentIsDry = 1
        if floorHeight#(cMapSizeX / 2 - tentDryRadius, cMapSizeZ / 2 - tentDryRadius) <= waterLevel then tentIsDry = 0
        if floorHeight#(cMapSizeX / 2                , cMapSizeZ / 2 - tentDryRadius) <= waterLevel then tentIsDry = 0
        if floorHeight#(cMapSizeX / 2 + tentDryRadius, cMapSizeZ / 2 - tentDryRadius) <= waterLevel then tentIsDry = 0
        if floorHeight#(cMapSizeX / 2 - tentDryRadius, cMapSizeZ / 2                ) <= waterLevel then tentIsDry = 0
        if floorHeight#(cMapSizeX / 2                , cMapSizeZ / 2                ) <= waterLevel then tentIsDry = 0
        if floorHeight#(cMapSizeX / 2 + tentDryRadius, cMapSizeZ / 2                ) <= waterLevel then tentIsDry = 0
        if floorHeight#(cMapSizeX / 2 - tentDryRadius, cMapSizeZ / 2 + tentDryRadius) <= waterLevel then tentIsDry = 0
        if floorHeight#(cMapSizeX / 2                , cMapSizeZ / 2 + tentDryRadius) <= waterLevel then tentIsDry = 0
        if floorHeight#(cMapSizeX / 2 + tentDryRadius, cMapSizeZ / 2 + tentDryRadius) <= waterLevel then tentIsDry = 0
    until tentIsDry = 1
return

rem Rotate smooth, and rotate in the direction with the lowest distance
rem "turn object left" ist das kommando
function smoothRotate#(von#, nach#, smoothness)
    if (von# > 270) and (nach# < 90)
        ret# = WrapValue(von# + (360 - von# + nach#)/smoothness)
    else
        if (von# < 90) and (nach# > 270)
            ret# = WrapValue(von# - (360 - nach# + von#)/smoothness)
        else
            ret# = von# + (nach# - von#)/smoothness
        endif
    endif
endfunction ret#

function floorHeight#(X#, Z#)
    ret# = Get Ground Height(MAT_Ground, X#, Z#)
ENDFUNCTION ret#

function upPressed()
    ret = UpKey()=1 or keystate(17)=1 or joystick up()=1
ENDFUNCTION ret

function leftPressed()
    ret = LeftKey()=1 or keystate(30)=1 or joystick left()=1
ENDFUNCTION ret

function rightPressed()
    ret = RightKey()=1 or keystate(32)=1 or joystick right()=1
ENDFUNCTION ret

function downPressed()
    ret = DownKey()=1 or keystate(31)=1 or joystick down()=1
ENDFUNCTION ret

function jumpPressed()
    ret = keystate(57)=1 or JOYSTICK FIRE A()=1
ENDFUNCTION ret

function TwoDigit$(value)
    if value < 10
        ret$ = "0"+STR$(value)
    else
        ret$ = STR$(value)
    ENDIF
ENDFUNCTION ret$

function mod(num,modulus)
    value=num-((num/modulus)*modulus)
endfunction value

function RndBetween(a,b)
    ret = a+Rnd(b-a)
ENDFUNCTION ret

function isInCircle(pX#,pZ#,cX#,cZ#,cR#)
    ret = sqrt( (pX#-cX#)*(pX#-cX#) + (pZ#-cZ#)*(pZ#-cZ#) ) <= cR#
ENDFUNCTION ret

function isInCircle3D(pX#,pY#,pZ#,cX#,cY#,cZ#,cR#)
    ret = sqrt( (pX#-cX#)*(pX#-cX#) + (pY#-cY#)*(pY#-cY#) + (pZ#-cZ#)*(pZ#-cZ#) ) <= cR#
ENDFUNCTION ret

_stop_game_sounds:
    gosub _stop_game_sounds_keep_background
    Stop Sound SFX_TitleMusic
    Stop Sound SFX_StormBG
    Stop Sound SFX_Radio
    Stop Sound SFX_ForestBG
return

_stop_game_sounds_keep_background:
    Stop Sound SFX_DeathScreen
    Stop Sound SFX_Walk_Earth
    Stop Sound SFX_Walk_Water
    Stop Sound SFX_Woosh
    Stop Sound SFX_HIT_SOIL
    Stop Sound SFX_HIT_WATER
    Stop Sound SFX_Jump
    if stage = 3
        for t = 0 to cMaxEnemies-1
            Stop Sound SFX_Monster_Base+t
        next t
    endif
return

type treeType
    x as float
    z as float
    drawn as boolean
endtype

type enemyType
    Speed as float
    WalkTimeout as float
    WalkTimeoutMin as float
    WalkTimeoutMax as float
    AwarenessRadius as float
    CurSpeed as float
    MaxSpeed as float
    Angle as float
    CurrentAnim as float
    IsAttacking as integer
endtype

PressJumpKey:
    if onGround=1
        play sound SFX_Jump
        JumpPosition#=floorHeight#(X#,Z#)
        velocityY# = JumpStartVelocity#
        rem When being under attack, you can jump higher (otherwise it is nearly impossible to get out of the claws)
        if underAttack = 1 then velocityY# = velocityY# * EmergencyJumpFactor#
        onGround = 0
    endif
return

ReleaseJumpKey:
    if velocityY# > MinFallVelocity#
        velocityY# = MinFallVelocity#
    endif
return

JumpUpdate:
    if onGround=0
        dec velocityY#, gravity#
        inc JumpPosition#, velocityY#

        curFloorHeight# = floorHeight#(X#,Z#)
        if JumpPosition# < curFloorHeight#
            JumpPosition# = curFloorHeight#
            velocityY# = 0.0
            onGround = 1
            gt = groundType(onGround, waterLevel)
            if gt = GROUNDTYPE_EARTH then
                play sound SFX_HIT_SOIL
            if gt = GROUNDTYPE_WATER then
                play sound SFX_HIT_WATER
        endif
    endif
return

function resizeImage(image as dword, width as dword, height as dword)
    make memblock from image MEM_ResizeSrc, image
    size = call dll(DLL_ForestDLL, "SIZ_DestSize", get memblock ptr(MEM_ResizeSrc), width, height)

    if size > 0
        make memblock MEM_ResizeDest, size
        call dll DLL_ForestDLL, "SIZ_Resize", get memblock ptr(MEM_ResizeSrc), get memblock ptr(MEM_ResizeDest), width, height
        make image from memblock image, MEM_ResizeDest
        delete memblock MEM_ResizeSrc
        delete memblock MEM_ResizeDest
    endif
endfunction

function LoadImageFullscreen(imgFN as string, imgID)
    Load Image imgFN, imgID
    width  = screen width()
    height = image height(imgID)*screen width()/1.0/image width(imgID);
    resizeImage(imgID, width, height)
ENDFUNCTION

_play_attack_sound:
    repeat
        r=RndBetween(0,NumberOfAttackSounds-1)
    UNTIL (r <> LastAttackSound) or (NumberOfAttackSounds = 1)
    LastAttackSound=r
    play sound SFX_Attack_Base+r
return

rem -- MUST STAY AT THE END OF THE PROGRAM --
_exit:
    call DLL DLL_ForestDLL, "COR_Uninitialize"
    delete dll DLL_ForestDLL

    exit
